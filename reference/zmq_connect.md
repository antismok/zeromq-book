# zmq_connect

## Краткое описание
zmq_connect - Создает исходящее соединение из сокета

## Синопсис

```
int zmq_connect (void *socket, const char *endpoint);
```

## Описание

*zmq_connect()* - функция соединяет *сокет* с *конечной точкой*, а затем принимает входящие соединения на этой *конечной точке*.

*Конечная точка* это строка состоящая из *транспорта* :// за которым следует *адрес* подключения. Транспорт определеяет основной использующийся протокол. Адрес указывает транспортный адрес подключения.

ZeroMQ предоставляет следующие транспорты:

- **tcp** 
	Однонаправленный транспорт TCP, подробнее [zmq_tcp(7)](zmq_tcp.md)
- **ipc**
	Локальный inter-process(межпроцессный) транспорт, подробнее [zmq_ipc(7)](zmq_ipcю.md)
- **inproc**
	Локальный in-process (inter-thread межпотоковый) странспорт, подробнее [zmq_inproc(7)](zmq_inproc.md)
- **pgm, epgm**
	Надежный широковещательный транспорт использующий PGM, подробнее [zmq_pgm(7)](zmq_pgm.md)
- **vmci**
	Интерфейс общения виртуальных машины (VMCI), подробнее [zmq_vmci(7)](zmq_vmci.md)

Каждый тип сокета ØMQ, кроме *ZMQ_PAIR*, поддерживает семантику «один ко многим» и «многие к одному». Точная семантика зависит от типа сокета и определяется в [zmq_socket (3)](zmq_socket.md).

Для большинства транспортов и сокетов подключение осуществляется по требованию ZeroMQ, а не в тот же момент. Таким образом, успешный вызов [zmq_connect()](zmq_connect.md) не означает, что соединение было или может быть фактически установлено. Из-за этого для большинства типов транспортов и сокетов порядок создания серверного и клиентского сокета, не имеет значения. Первое исключение - при использовании транспорта **inproc://**: вы должны вызвать [zmq_bind()](zmq_bind.md) перед вызовом [zmq_connect()](zmq_connect.md). Второе исключение - это сокеты ZMQ_PAIR, которые не подключаются автоматически к конечным точкам.

После выполнения [zmq_connect()](zmq_connect()) для типов сокетов, кроме ZMQ_ROUTER, сокет переходит в свое обычное состояние готовности. [zmq_bind()](zmq_bind.md) ведет себя по другому, после вызова сокет переходит в тихий режим и отбрасывает либо блокирует сообщения взависимости от типа сокета, как описана в [zmq_socket(3)](zmq_socket.md). Сокет ZMQ_ROUTER переходит в свое нормальное состояние для специфичного пира, только после хендшейка с этим пиром, что может занять неопределенное время.

## Возвращаемое значение

zmq_connect() - возвращает ноль в случае успеха. В противном случае возвращает -1 и устанавливает errno в одно из значений перечисленных ниже.

## Ошибки

**EINVAL**
	Указанная конечная точка не действительна.
    
**EPROTONOSUPPORT**
	Запрашиваемый транспортный протокол не поддерживается.
    
**ENOCOMPATPROTO**
	Запрашиваемый транспортный протокол не совместим с типом сокета.
    
**ETERM**
	Контекст ØMQ в котором нахотся сокет был уничтожен.
    
**ENOTSOCK**
	Предоставлен не действительный сокет.
    
**EMTHREAD**
Нет потока ввода-вывода для выполнения задачи.

## Пример

```
/* Создание сокета подписщика ZMQ_SUB */
void *socket = zmq_socket (context, ZMQ_SUB);
assert (socket);

/* Подключение сокета по межпотоковому транспортному протоколу с адресом 'my_publisher'*/
int rc = zmq_connect (socket, "inproc://my_publisher");
assert (rc == 0);

/* Подключение сокета к хосту server001 на порт 5555 с использованием TCP транспорта */
rc = zmq_connect (socket, "tcp://server001:5555"); assert (rc == 0);
```

## Смотрите также
[zmq_bind(3)](zmq_bind.md) [zmq_socket(3)](zmq_socket.md) [zmq(7)](zmq.md)

## Authors
Страница написана сообществом ØMQ. Для внесения измененй ознакомьтесь с политикой для контрибьюторов ØMQ на страницу [http://www.zeromq.org/docs:contributing.](http://www.zeromq.org/docs:contributing)
Перевел Сарицкий Роман <saritskiy.r@gmail.com>






















