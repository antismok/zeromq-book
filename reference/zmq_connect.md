# zmq_connect

## Краткое описание
zmq_connect - Создает исходящее соединение из сокета

## Синопсис

```
int zmq_connect (void *socket, const char *endpoint);
```

## Описание

*zmq_connect()* - функция соединяет *сокет* с *конечной точкой*, а затем принимает входящие соединения на этой *конечной точке*.

*Конечная точка* это строка состоящая из *транспорта* :// за которым следует *адрес* подключения. Транспорт определеяет основной использующийся протокол. Адрес указывает транспортный адрес подключения.

ZeroMQ предоставляет следующие транспорты:

- **tcp** 
	Однонаправленный транспорт TCP, подробнее [zmq_tcp(3)](zmq_tcp.md)
- **ipc**
	Локальный inter-process(межпроцессный) транспорт, подробнее [zmq_ipc(7)](zmq_ipcю.md)
- **inproc**
	Локальный in-process (inter-thread межпотоковый) странспорт, подробнее [zmq_inproc(7)](zmq_inproc.md)
- **pgm, epgm**
	Надежный широковещательный транспорт использующий PGM, подробнее [zmq_pgm(7)](zmq_pgm.md)
- **vmci**
	Интерфейс общения виртуальных машины (VMCI), подробнее [zmq_vmci(7)](zmq_vmci.md)

Каждый тип сокета ØMQ, кроме *ZMQ_PAIR*, поддерживает семантику «один ко многим» и «многие к одному». Точная семантика зависит от типа сокета и определяется в [zmq_socket (3)](zmq_socket.md).

Для большинства транспортов и сокетов подключение не производится немедленно, а по требованию ZeroMQ. Таким образом, успешный вызов [zmq_connect()](zmq_connect.md) не означает, что соединение было или может быть фактически установлено. Из-за этого для большинства типов транспортов и сокетов порядок создания серверного и клиентского сокета, не имеет значения. Первое исключение - при использовании **inproc://transport:** вы должны вызвать [zmq_bind()](zmq_bind.md) перед вызовом [zmq_connect()](zmq_connect.md). Второе исключение - это сокеты ZMQ_PAIR, которые не подключаются автоматически к конечным точкам.
