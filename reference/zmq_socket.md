zmq_socket

## Краткое описание
zmq_socket - Создает сокет ØMQ

## Синопсис
```
void *zmq_socket (void *context, int type);
```

## Описание
Функция zmq_socket создает сокет в указанном контексте и возвращает дескриптов внось созданного сокета. Аргумент type указывает тип сокета, который определяет семантику связи через сокет.
Изначально сокет не связан и не указывает ни на какие конечные точки. Чтобы начать обмен сообщениями, сокет должен быть подключени хотя бы к одной конечной точке при помощи [zmq_connect(3)](zmq_connect.md), или начать прослушку при помощи [zmq_bind(3)](zmq_bind.md).

**Ключевый отличия от обычных сокетов.**
Традиционные сокеты предоставляют два вида интерфейсов для пересылки данных. Первый это надежный синхронный потоковый интерфейс(**SOCK_STREAM**), второй это не надежный датаграмный интерфейс(**SOCK_DGRAM**). ØMQ сокеты представляют собой абстракцию асинхронной очереди сообщений с точной семантикой очереди в зависимости от используемого типа сокета. Там где общепринятые сокеты передают набор байт и датаграмм, сокеты ØMQ предают дискретные сообщения.


Управление асинхронностью, соединениями, переподключениями, эффективной отправкой сообщений, делается под капотом ØMQ и не требуют вашего вмешательства. Кроме того сообщения могут быть поставлены в очередь на отправку без установленного соединения с конечным узлом.

Традиционные сокеты могут устанавливать только соединение один-к-одному(два пира), один-ко-многим (один сервер и много клиентов) и в редких случаях широковещательные(broadcast). У ØMQ же все сокеты, за исключением ZMQ_PAIR, могут быть одновременно подключены к нескольким конечным точкам с помощью zmq_connect(), одновременно принимая входящие соединения от нескольких конечных точек, подвешенных на сокет, с помощью zmq_bind(), что позволяет устанавливать отношения «многие ко многим».

ØMQ имеет потокобезопасные сокеты, а также не потокобезопасные. Приложения НЕ ДОЛЖНЫ использовать не потокобезопасные типы сокетов в многопоточных приложениях, за исключением миграции с однопоточных на многкопоточны и в этом случае все равно необходимо предусмотреть защитный слой для памяти такой как "full fence".

Потокобезопасные сокеты: \* ZMQ_CLIENT \* ZMQ_SERVER \* ZMQ_DISH \* ZMQ_RADIO \* ZMQ_SCATTER \* ZMQ_GATHER

**Типы сокетов** 
Ниже представлены типы сокетов ØMQ которые сгруппированы по *шаблонам передачи сообщений*.

#### Паттерн клиент-сервер. (Client-server pattern)

Паттерн клиент-сервер используется для взаимодействия между сервером и одним или несколькими клиентами. Первое действие всегда за клиентом, после чего оба могут обмениваться асинхронными сообщениями.

Формат определен на странице [https://rfc.zeromq.org/spec:42/C4/](https://rfc.zeromq.org/spec:42/C4/).

**Примечание:** Этот паттерн предназначен прийти на замену шаблону ZMQ_DEALER/ZMQ_ROUTER для построения клиент-серверных архитектур, а также ZMQ_REP/ZMQ_REQ для архитектур запрос-ответ.

#### ZMQ_CLIENT
Сокет ZMQ_CLIENT начинает общение с серверным сокетом ZMQ_SERVER. Подключиться может любой пир, хотя обычно рекомендуется сначала начать прослушку ZMQ_SERVER и полключить сокет ZMQ_CLIENT. Если сокет ZMQ_CLIENT уже установил соединенине, то [zmq_send(3)](zmq_send.md),будет принимать сообщения, класть их в свою внутреннюю очередь и отправлять их так с максимально возможной скоростью сети. Если буфер по каким либо причинам превысил вотерлинию(), например из-за медленной сети или обрыва соединения, то по умолчанию [zmq_send(3)](zmq_send.md) будет заблокирован и перестанет принимать сообщения. Но [zmq_send(3)](zmq_send.md) не будет отбрасывать сообщения.

Когда сокет ZMQ_CLIENT подключен к нескольким серверным сокетам ZMQ_SERVER, то исходящие сообщения будут отправляться по принципуround-robin(балансировки нагрузки). В свою очередь ZMQ_CLIENT получает сообщения от всех ZMQ_SERVER по принципу справедливой очереди(Fair-queue). Такое использование целесообразно только для протоколов без сохранения состояния.

ZMQ_CLIENT потокобезопасе и может используваться одновременно в нескольких потоках.

Обратите внимание, что ответ от ZMQ_SERVER получит тот клиентский сокет который первым вызовет libzmq:zmq_msg_recv. Если вы хотите получать ответ именно тем клиентом, кто отправил запрос, вам необходимо использовать подход с одним ZMQ_CLIENT сокетом на поток.

Сокеты ZMQ_CLIENT являются потокобезопасными. Они не принимают поддерживают параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это специально запрещает авторазбивку сообщения, чтобы вы сами докрутили интерфейс и позаботились о разбивке вашего/сборке вашего сообщения.

**Итоговые характеристики ZMQ_CLIENT**

|||
|--------|--------|
| Совместимость с типами сокетов 	| ZMQ_SERVER 	  |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Round-robin (балансировка)	  |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие беззвучного режима			| Бликоровка      |

#### ZMQ_SERVER

Сокет ZMQ_SERVER общается с ZMQ_CLIENT сокетами. Сокет ZMQ_SERVER только отвечает на запросы от ZMQ_CLIENT, которые всегда инициируют обмен.
Каждое отправленное сообщение имеет routing_id - беззнаковое 32-битное число. Приложение может получить енр при помощи [zmq_msg_routing_id(3)](zmq_msg_routing_id.md). Чтобы отправить сообщение пиру ZMQ_CLIENT, приложение должно сначала установить routing_id для сообщения исползуя [zmq_msg_set_routing_id(3)](zmq_msg_set_routing_id.md).

Если routing_id не указан или указывает на отключенного пира, то вызов метода отправки развалится с ошибкой EHOSTUNREACH. Если буфер исходящих сообщений для клиентского пира переполнен, вызов отправки будет блокирован, за исключением случая когда указан параметр ZMQ_DONT_WAIT, в таком случае мы получим ошибку EAGAIN. Сокет ZMQ_SERVER в обоих случаях не отбрасывает сообщения.

Сокет ZMQ_SERVER является потокобезопасным. Он не поддерживает параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это ограничение наложено специально, чтобы вы подумали сами как будет организована реализация разбивки и сборки сообщений.

**Итоговые характеристики ZMQ_SERVER**

|||
|--------|--------|
| Совместимость с типами сокетов  |	ZMQ_CLIENT |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Читайте текст   |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие беззвучного режима			| Бликоровка или ошибка EAGAIN |


### Паттерн радио-антенна (Radio-dish pattern)
Паттерн радио антненна предназначен для рассылки сообщений один-ко-многим от одного издателя ко множеству подписок по типу fanout(прим. терминология взята от amqp).

Радио антенна использует группы (а Pub-sub использует темы), сокеты "Антенны" согут подписаться на группу и получать сообщения только этой группы. Группы это строки с замыкающим null, длинна которых не превышает 16 символов включая замыкающий null. Мы собераемся увеличить это количество до 40 включая null.

Радио антенна фильтрует группы по точному совпадению в то время как pub-sub(издатель-подписчик), фильтрует свои темы по префиксному типу.

**Внимание! Паттерн радио-антенна на стадии разработки.**

Паттерн радио-антенна призван сменить устаревший петтерн pub-sub(издатель-подписчик).

### ZMQ_RADIO

Сокет ZMQ_RADIO используется издателем для мульти рассылки сообщений. Каждое сообщение пренадлежит какой-то группе и определяется методом [zmq_msg_set_group(3)](zmq_msg_set_group.md). Сообщения отсыдается всем членам этой группы. Для данного типа сокетов не реализована функция [zmq_recv(3)](zmq_recv.md), так как осуществляет только рассылку.

Данный тип сокета никогда не блокирует отправку сообщений. Если произойдет переполнение буфера очереди какого-то из клиентов, то все сообщения после этого будут просто отбрасываться до тех пор пока буфер не освободится.

Сокет ZMQ_RADIO является потокобезопасным. Он работает только с простыми сообщениями и не поддерживает параметр ZMQ_SNDMORE.

**Итоговые характеристики ZMQ_RADIO**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_DISH |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_DISH

Сокет ZMQ_DISH используется *подписчиком* для подписки на группы сообщений публикуемых *радио*. Изначально ZMQ_DISH не подписан на какие-либо группы, для подписки на какую-либо группу используйте [zmq_join(3)](zmq_join.md). Для получения подписок используйте [zmq_msg_group(3)](zmq_msg_group.md). Функция zmq_send() не реализована для данного типа сокетов.

Сокет ZMQ_RADIO является потокобезопасным. Он работает только с простыми сообщениями и не поддерживает параметр ZMQ_SNDMORE.

**Итоговые характеристики ZMQ_RADIO**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_RADIO |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение |
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|

## Паттерн издатель-подписчик (Publish-subscribe).

Паттерн издатель-подписчик предназначен для рассылки сообщений один-ко-многим от одного издателя ко множеству подписок по типу fanout(прим. терминология взята от amqp).

Паттерн издатель-подписчик формализован вот тут [http://rfc.zeromq.org/spec:29](http://rfc.zeromq.org/spec:29).

### ZMQ_PUB

Сокет **ZMQ_PUB** используется для рассылки данных. Отправленные сообщения доставляются по типу fan-out всем подключенным пирам. Данный тип сокета не поддерживает получение данных и не реализовывает функцию zmq_recv(3).

Данный тип сокета никогда не блокирует отправку сообщений. Если произойдет переполнение буфера очереди какого-то из клиентов, то все сообщения после этого будут просто отбрасываться до тех пор пока буфер не освободится.

**Итоговые характеристики ZMQ_PUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_SUB, ZMQ_XSUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_SUB

Тип сокета **ZMQ_SUB** используется подписчиком для подписки на сообщения отправленные издателем. Изначально сокет не подписан ни на какие сообщения, чтобы подписаться на какое-то сообщение используйте метод [zmq_setsockopt(3)](zmq_setsockopt.md) с параметром **ZMQ_SUBSCRIBE**. Сокет **ZMQ_SUB** не отправляет никакие сообщения и не реализует функццию zmq_send().

**Итоговые характеристики ZMQ_SUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUB, ZMQ_XPUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение |
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|

### ZMQ_XPUB

По факту тоже самое, что и **ZMQ_PUB**, за исключение того, что можно получать сообщения о подписке/отписе от пиров. Сообщение подписки - это байт 1 (для подписок) или байт 0 (для отписок), за которым следует тело подписки. Сообщения без префикса sub / unsub также принимаются, но не влияют на статус подписки.

Основным если не единственным применение **ZMQ_XPUB** + **ZMQ_XSUB** это создание возможности получать одним подписчиком сообщения от нескольких издателей. По факту реализация проксирования и ничего больше.

**Итоговые характеристики ZMQ_XPUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_SUB, ZMQ_XSUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Отправка сообщений, получение сообщений подписки |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_XSUB

По факту тоже самое, что и **ZMQ_SUB**, за исключение того, что для подписки необходимо отправлять сообщения. Сообщение подписки - это байт 1 (для подписок) или байт 0 (для отписок), за которым следует тело подписки. Сообщения без префикса sub/unsub также принимаются, но не влияют на статус подписки.

Основным если не единственным применение **ZMQ_XPUB** + **ZMQ_XSUB** это создание возможности получать одним подписчиком сообщения от нескольких издателей. По факту реализация проксирования и ничего больше.

**Итоговые характеристики ZMQ_XSUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUB, ZMQ_XPUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Получение сообщений, отправка сообщений подписки|
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|
| Действие беззвучного режима			| Отбрасывание сообщений |

## Паттерн конвейер (Pipeline pattern)

Шаблон конвейер используется для доставки сообщений к нодам по конвейеру. Данные постоянно движутся, как по конвейеру и каждый этап коневейера связан хотя бы с одной нодой. Когда к конвейеру подключено несколько нод сообщения распределяются по принципу round-robin(балансировки нагрузки).

Конвейер описан на странице [http://rfc.zeromq.org/spec:30.](http://rfc.zeromq.org/spec:30)

### ZMQ_PUSH

Тип сокета ZMQ_PUSH используется для отправки сообщений на конвейерную ленту. Сообщения распределяются между всеми *нодами* подключенными к ленте конвейера по принципу round-robin(балансировки нагрузки). Лента конвейера односторонняя и метод zmq_recv() для этого сокета не реализован.

Когда сокет входит в беззвучный режим, по причине того, что у всех подключенных сокетов была превышена вотерлиния или просто нет подключенных клиентов, функция [zmq_send(3)](zmq_send) блокируется до тех пор пока не пойвится способный принимать сообщение клиент. Сообщения не отбрасываются.

**Итоговые характеристики ZMQ_PUSH**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PULL |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка|
| Маршрутизация исходящих сообщений | балансировки нагрузки Round-robin   |
| Маршрутизация входящих сообщений  | отсутствует|
| Действие беззвучного режима		| блокировка |

### ZMQ_PULL

Тип сокета ZMQ_PULL используется для получения сообщения с ковейера, которые распределяются по принципу справедливая очередь (Fair-queued). Реализация метода zmq_send() для этого типа сокета отсутствует.

**Итоговые характеристики ZMQ_PULL**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUSH |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение|
| Маршрутизация исходящих сообщений | отсутствует   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|
| Действие беззвучного режима		| блокировка |

## Паттерн эксклюзивная пара (Exclusive pair pattern)

Данный тип сокета подразумевает общение только между двумя пирами. Этот паттерн используется для межпроцессного обмена через транспорт [zmq_inproc(7)](zmq_inproc.md)

Спецификация описана тут [http://rfc.zeromq.org/spec:31.](http://rfc.zeromq.org/spec:31.)

### ZMQ_PAIR

Тип сокета ZMQ_PAIR единовременно может быть подключен только к одному пиру. На сообщениях, отправляемых через сокет ZMQ_PAIR, маршрутизация или фильтрация сообщений не выполняются.

Когда сокет входит в беззвучный режим, по причине превышения вотерлинии или отсутствия подключения, функция [zmq_send(3)](zmq_send) блокируется до тех пор пока не пойвится способный принимать сообщение пир. Сообщения не отбрасываются.

Данный тип сокета спроектирован для межпроцессного взаимодействия через транспорт [zmq_inproc(7)](zmq_inproc.md) и не поддерживает такую функциональность как автопереподключение.

**Итоговые характеристики ZMQ_PAIR**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PAIR |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Без ограничений |
| Маршрутизация исходящих сообщений | Отсутствует   |
| Маршрутизация входящих сообщений  | Отсутствует|
| Действие беззвучного режима		| блокировка |

## Нативный паттерн (Native pattern)

 Нативный паттерн используется для связи с пирами TCP и позволяет саинхронное общнение в любом направлении.

###  ZMQ_STREAM

Тип сокета ZMQ_STREAM предназначен для обмена по TCP транспорту с не ØMQ пирами. Сокет ZMQ_STREAM может выступать в роли клиента и/или сервера, отправляя и/или получая данные по TCP асинхронно.

При получении данный по TCP, сокет ZMQ_STREAM должен добавить в начало сообщения идентификатор пира отправителя, до его передачи приложению. Все входящие сообщения распределяются по принципу fair-queued (справедливой очереди).

Перед отправкой сообщения ZMQ_STREAM должен удалить первую часть сообщения содержащую адрес и использовать этот адрес для маршрутизации. Если маршрутизация не возможна, то выбросить ошибки EHOSTUNREACH или EAGAIN.

Чтобы подключиться к серверу, вызовите zmq_connect, а затем извлеките идентификатор сокета вызвав zmq_getsockopt с параметром ZMQ_IDENTITY.

Для того чтобы закрыть определенное соединение, отправьте фрейм с идентификатором сразу после отправки пустого сообщений. (Подробнее смотрите в примерах).

После установки соединения, приложение получит пустой фрейм. Аналогично и при отключении пира, либо разрыве соединения.

Вы должны отправлять идентификационный фрейм предшествующий фрейму данных. Для отправки идентификационных фреймов требуется флаг ZMQ_SNDMORE, однако для фреймов данных он будет игнорироваться.

**Итоговые характеристики ZMQ_STREAM**

|||
|--------|--------|
| Совместимость с типами сокетов    | отсутствует |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Без ограничений |
| Маршрутизация исходящих сообщений | Читайте документацию   |
| Маршрутизация входящих сообщений  | fair-queue (справедливая очередь)|
| Действие беззвучного режима		| EAGAIN |

Паттерн запрос-ответ (Request-reply pattern)

Паттерн запро-ответ используется для отправки запроса от одного ZMQ_REQ одному и более ZMQ_REP сервису и получения ответов на каждый отправленный запрос.

Спецификация паттерна запрос-ответ описана тут [http://rfc.zeromq.org/spec:28.](http://rfc.zeromq.org/spec:28.)

Примечание: Этот шаблон устарел, ему на смену пришел шаблон клиент-сервер.

### ZMQ_REQ

Сокет ZMQ_REQ используется для отправки запроса и получение на него ответа от сервиса. Данный тип сокете подразумевает определенную последовательность вызовов. Сначала вызов метода запроса zmq_send() и после этого вызов zmq_recv(). Каждый запрос распределяется между сервисами обработчиками по принципу round-robine и каждый ответ будет сопоставлен с последним отправленным запросом.

Если нет доступных сервисов для обработки запросов, отправка запроса будет блокирована до тех пор пока не появится обработчик (На самом деле не совсем так, почему-то тут не написано что есть параметр ожидания и таймаута). ZMQ_REQ не отбрасывает сообщения.

**Итоговые характеристики ZMQ_REQ**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_REP, ZMQ_ROUTER |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| последовательность: Отправка, Получение, Отправка, Получение |
| Маршрутизация исходящих сообщений | round-robin (балансировка нагрузки)  |
| Маршрутизация входящих сообщений  | Last peer (сопоставление с последним выданным запросом) |
| Действие беззвучного режима		| Block (блокировка) |

### ZMQ_REP

Тип сокета ZMQ_REP используется сервисом для получения запроса и отправки на него ответа. Данный тип сокета подразумевает только определенную последовательность вызовов методов, сначала zmq_recv(request) и только после этого zmq_send(reply). Каждый входящий запрос от клиентов распределяется по принципу fair-queued (справедливой очереди), а каждый ответ путем сопоставления с последним запросом клиента. Если отвечать оказывается некому, сокет тихонечко выбросит ответ и продолжит работать дальше.

**Итоговые характеристики ZMQ_REQ**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_REQ, ZMQ_ROUTER |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| последовательность: Получение, Отправка, Получение, Отправка |
| Маршрутизация исходящих сообщений | round-robin (балансировка нагрузки)  |
| Маршрутизация входящих сообщений  |  Last peer (сопоставление с последним выданным запросом) |

### ZMQ_DEALER

Сокет ZMQ_DEALER это продвинутый паттерн использования сокетов запрос-ответ. Рассылка сообщений балансируется по round-robin между всеми подключенными пирами, а получение входящих сообщений происходит по справедливой очереди (fair-queued) от всех подключенных пиров.

Когда ZMQ_DEALER входит в беззучный режим, если превышена вотерлиния либо отсутствуют подключенные пиры, отправка любых сообщения с использованием [zmq_send(3)](zmq_send) будет заблокирована, до момента отвобождения буффера или появления пиров. Сообщения в этом режиме не отбрасываются.

Когда сокет ZMQ_DEALER подключен к сокету ZMQ_REP, каждое отправленное сообщение должно состоять из пустого фрейма разделителя, за которым следует один и более фреймов тела сообщения.

**Итоговые характеристики ZMQ_DEALER**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_ROUTER, ZMQ_REP, ZMQ_DEALER |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| последовательность: Отправка, Получение, Отправка, Получение |
| Маршрутизация исходящих сообщений | round-robin (балансировка нагрузки)  |
| Маршрутизация входящих сообщений  | Last peer (сопоставление с последним выданным запросом) |
| Действие беззвучного режима		| Block (блокировка) |

### ZMQ_ROUTER

Сокет ZMQ_ROUTER это продвинутый паттерн использования сокетов запрос-ответ. После получения сообщения ZMQ_ROUTER должен добавить в начало сообщения идентификатор отправителя сообщения и только после этого отдать сообщения приложению. Все входящие сообщения обрабатываются по принципу fair-queue(справедливой очереди). Перед отправкой сообщения сокет ZMQ_ROUTER должен удалить первую часть сообщения содержащую идентификатор и использовать его для маршрутизации. Если пир больше не существует и параметр ZMQ_ROUTER_MANDATORY сокета не установлен в 1, то по умолчанию сообщение будет тихонечко отброшено.

Когда ZMQ_ROUTER впадает в беззвучный режим, по причине превышения вотерлинии у всех сокетов, то все сообщения будут отбрасываться пока он не выйдет из этого режима. Аналогично произойдет с теми сообщениями которые смаршрутизированы на единичный сокет у которого превышена вотерлиния. Все вышесказанное справедливо если не установлен параметр сокета ZMQ_ROUTER_MANDATORY.

Когда сокет ZMQ_REQ подключен к сокету ZMQ_ROUTER, в дополнение к идентификатору пира отправителя каждое полученное сообщение должно содержать пустой фрейм разделитель. Следовательно, структура каждого сообщения полученного приложением выглядит следующим образом: Один или несколько фреймов идентификации идентификации, фрейм разделитель, один или несколько фреймов полезных данных. При отправке ответов в сокет ZMQ_REQ приложение должно включать фрейм разделитель.

**Итоговые характеристики ZMQ_DEALER**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_DEALER, ZMQ_REQ, ZMQ_ROUTER |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| последовательность: Отправка, Получение, Отправка, Получение |
| Маршрутизация исходящих сообщений | Читайте текст  |
| Маршрутизация входящих сообщений  | fair-queued (справедливая очередь) |
| Действие беззвучного режима		| Block (блокировка. Есть ньюансы, смотрите текст) |

## Возвращаемое значение
zmq_socket() в случае успеха возвращает дескриптор созданного сокета. В случае ошибки возвращает null и устанавливает errno в одно из значений указанных ниже.

## Ошибки

- EINVAL
Указан не существующий тип сокета.
- EFAULT
Передан не верный контекст.
- EMFILE
Первышен установленный лимит сокетов ØMQ.
- ETERM
Указанный контекст был закрыт.

## Пример

**Создание простого HTTP сервера с использованием zmq_stream сокета.**

```
void *ctx = zmq_ctx_new ();
assert (ctx);
/* Создание сокета ZMQ_STREAM */
void *socket = zmq_socket (ctx, ZMQ_STREAM);
assert (socket);

int rc = zmq_bind (socket, "tcp://*:8080");
assert (rc == 0);

/* Структура для хранения идентификатор ZMQ_STREAM*/
uint8_t id [256];
size_t id_size = 256;

/* Структура для хранения полученных данных ZMQ_STREAM*/
uint8_t raw [256];
size_t raw_size = 256;

while (1) {
 /* Получение HTTP запроса; ID фрейма и запрос */
 id_size = zmq_recv (socket, id, 256, 0);
 assert (id_size > 0);
 do {
 	raw_size = zmq_recv (socket, raw, 256, 0);
 	assert (raw_size >= 0);
 } while (raw_size == 256);

 /* Подготовка ответа */
 char http_response [] =
 "HTTP/1.0 200 OK\r\n"
 "Content-Type: text/plain\r\n"
 "\r\n"
 "Hello, World!";
 /* Посылает идентификационный фрейм с последующим ответом */
 zmq_send (socket, id, id_size, ZMQ_SNDMORE);
 zmq_send (socket, http_response, strlen (http_response), 0);
 /* Закрываем соединение. Отправляем идентификационный фрейм с последующим пустым сообщением */
 zmq_send (socket, id, id_size, ZMQ_SNDMORE);
 zmq_send (socket, 0, 0, 0);
}
zmq_close (socket); zmq_ctx_destroy (ctx);
```

**Пример от переводчика**
Самый простой пример ZMQ_XPUB ZMQ_XSUB это использование проксирования. Есть и более инетересные, например если нужно расширить роутинг итд.

**Проксирование**
```
void *ctx = zmq_ctx_new ();

void *xpub = zmq_socket(ctx, ZMQ_XPUB);
int rc = zmq_bind(xpub, "tcp://127.0.0.1:8080");

void *xsub = zmq_socket(ctx, ZMQ_XSUB);
int rc1 = zmq_bind(xsub, "tcp://127.0.0.1:8081");

void *pub = zmq_socket(ctx, ZMQ_PUB);
int rc2 = zmq_bind(pub, "tcp://127.0.0.1:8082");

zmq_proxy (xpub, xsub, pub);
```
## Смотрите также
[zmq_init(3)](zmq_init.md) [zmq_setsockopt(3)](zmq_setsockopt.md) [zmq_bind(3)](zmq_setsockopt.md) [zmq_connect(3)](zmq_connect.md) [zmq_send(3)](zmq_send.md) [zmq_recv(3)](zmq_recv.md) [zmq_inproc(7)](zmq_inproc.md) [zmq(7)](zmq.md)

## Authors
Страница написана сообществом ØMQ. Для внесения измененй ознакомьтесь с политикой для контрибьюторов ØMQ на страницу [http://www.zeromq.org/docs:contributing.](http://www.zeromq.org/docs:contributing)
Перевел Сарицкий Роман <saritskiy.r@gmail.com>