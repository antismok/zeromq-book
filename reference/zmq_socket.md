zmq_socket

## Краткое описание
zmq_socket - Создает сокет ØMQ

## Синопсис
```
void *zmq_socket (void *context, int type);
```

## Описание
Функция zmq_socket создает сокет в указанном контексте и возвращает дескриптов внось созданного сокета. Аргумент type указывает тип сокета, который определяет семантику связи через сокет.
Изначально сокет не связан и не указывает ни на какие конечные точки. Чтобы начать обмен сообщениями, сокет должен быть подключени хотя бы к одной конечной точке при помощи [zmq_connect(3)](zmq_connect.md), или начать прослушку при помощи [zmq_bind(3)](zmq_bind.md).

**Ключевый отличия от обычных сокетов.**

#### Шаблон клиент-сервер.

Шаблон клиент-сервер используется для взаимодействия между сервером и одним или несколькими клиентами. Первое действие всегда за клиентом, после чего оба могут обмениваться асинхронными сообщениями.

Формат определен на странице [https://rfc.zeromq.org/spec:42/C4/](https://rfc.zeromq.org/spec:42/C4/).

**Примечание:** Этот шаблон предназначен прийти на замену шаблону ZMQ_DEALER/ZMQ_ROUTER для построения клиент-серверных архитектур, а также ZMQ_REP/ZMQ_REQ для архитектур запрос-ответ.

#### ZMQ_CLIENT
Сокет ZMQ_CLIENT начинает общение с серверным сокетом ZMQ_SERVER. Подключиться может любой пир, хотя обычно рекомендуется сначала начать прослушку ZMQ_SERVER и полключить сокет ZMQ_CLIENT. Если сокет ZMQ_CLIENT уже установил соединенине, то [zmq_send(3)](zmq_send.md),будет принимать сообщения, класть их в свою внутреннюю очередь и отправлять их так с максимально возможной скоростью сети. Если буфер по каким либо причинам превысил вотерлинию(), например из-за медленной сети или обрыва соединения, то по умолчанию [zmq_send(3)](zmq_send.md) будет заблокирован и перестанет принимать сообщения. Но [zmq_send(3)](zmq_send.md) не будет отбрасывать сообщения.

Когда сокет ZMQ_CLIENT подключен к нескольким серверным сокетам ZMQ_SERVER, то исходящие сообщения будут отправляться по принципуround-robin(балансировки нагрузки). В свою очередь ZMQ_CLIENT получает сообщения от всех ZMQ_SERVER по принципу справедливой очереди(Fair-queue). Такое использование целесообразно только для протоколов без сохранения состояния.

ZMQ_CLIENT потокобезопасе и может используваться одновременно в нескольких потоках.

Обратите внимание, что ответ от ZMQ_SERVER получит тот клиентский сокет который первым вызовет libzmq:zmq_msg_recv. Если вы хотите получать ответ именно тем клиентом, кто отправил запрос, вам необходимо использовать подход с одним ZMQ_CLIENT сокетом на поток.

Сокеты ZMQ_CLIENT являются потокобезопасными. Они не принимают поддерживают параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это специально запрещает авторазбивку сообщения, чтобы вы сами докрутили интерфейс и позаботились о разбивке вашего/сборке вашего сообщения.

**Итоговые характеристики ZMQ_CLIENT**

|||
|--------|--------|
| Совместимость с типами сокетов 	| ZMQ_SERVER 	  |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Round-robin (балансировка)	  |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие тихого режима			| Бликоровка      |

## Возвращаемое значение

## Ошибки

## Пример

## Смотрите также

## Authors
Страница написана сообществом ØMQ. Для внесения измененй ознакомьтесь с политикой для контрибьюторов ØMQ на страницу [http://www.zeromq.org/docs:contributing.](http://www.zeromq.org/docs:contributing)
Перевел Сарицкий Роман <saritskiy.r@gmail.com>