zmq_socket

## Краткое описание
zmq_socket - Создает сокет ØMQ

## Синопсис
```
void *zmq_socket (void *context, int type);
```

## Описание
Функция zmq_socket создает сокет в указанном контексте и возвращает дескриптов внось созданного сокета. Аргумент type указывает тип сокета, который определяет семантику связи через сокет.
Изначально сокет не связан и не указывает ни на какие конечные точки. Чтобы начать обмен сообщениями, сокет должен быть подключени хотя бы к одной конечной точке при помощи [zmq_connect(3)](zmq_connect.md), или начать прослушку при помощи [zmq_bind(3)](zmq_bind.md).

**Ключевый отличия от обычных сокетов.**
Традиционные сокеты предоставляют два вида интерфейсов для пересылки данных. Первый это надежный синхронный потоковый интерфейс(**SOCK_STREAM**), второй это не надежный датаграмный интерфейс(**SOCK_DGRAM**). ØMQ сокеты представляют собой абстракцию асинхронной очереди сообщений с точной семантикой очереди в зависимости от используемого типа сокета. Там где общепринятые сокеты передают набор байт и датаграмм, сокеты ØMQ предают дискретные сообщения.


Управление асинхронностью, соединениями, переподключениями, эффективной отправкой сообщений, делается под капотом ØMQ и не требуют вашего вмешательства. Кроме того сообщения могут быть поставлены в очередь на отправку без установленного соединения с конечным узлом.

Традиционные сокеты могут устанавливать только соединение один-к-одному(два пира), один-ко-многим (один сервер и много клиентов) и в редких случаях широковещательные(broadcast). У ØMQ же все сокеты, за исключением ZMQ_PAIR, могут быть одновременно подключены к нескольким конечным точкам с помощью zmq_connect(), одновременно принимая входящие соединения от нескольких конечных точек, подвешенных на сокет, с помощью zmq_bind(), что позволяет устанавливать отношения «многие ко многим».

ØMQ имеет потокобезопасные сокеты, а также не потокобезопасные. Приложения НЕ ДОЛЖНЫ использовать не потокобезопасные типы сокетов в многопоточных приложениях, за исключением миграции с однопоточных на многкопоточны и в этом случае все равно необходимо предусмотреть защитный слой для памяти такой как "full fence".

Потокобезопасные сокеты: \* ZMQ_CLIENT \* ZMQ_SERVER \* ZMQ_DISH \* ZMQ_RADIO \* ZMQ_SCATTER \* ZMQ_GATHER

**Типы сокетов** 
Ниже представлены типы сокетов ØMQ которые сгруппированы по *шаблонам передачи сообщений*.

#### Паттерн клиент-сервер. (Client-server pattern)

Паттерн клиент-сервер используется для взаимодействия между сервером и одним или несколькими клиентами. Первое действие всегда за клиентом, после чего оба могут обмениваться асинхронными сообщениями.

Формат определен на странице [https://rfc.zeromq.org/spec:42/C4/](https://rfc.zeromq.org/spec:42/C4/).

**Примечание:** Этот паттерн предназначен прийти на замену шаблону ZMQ_DEALER/ZMQ_ROUTER для построения клиент-серверных архитектур, а также ZMQ_REP/ZMQ_REQ для архитектур запрос-ответ.

#### ZMQ_CLIENT
Сокет ZMQ_CLIENT начинает общение с серверным сокетом ZMQ_SERVER. Подключиться может любой пир, хотя обычно рекомендуется сначала начать прослушку ZMQ_SERVER и полключить сокет ZMQ_CLIENT. Если сокет ZMQ_CLIENT уже установил соединенине, то [zmq_send(3)](zmq_send.md),будет принимать сообщения, класть их в свою внутреннюю очередь и отправлять их так с максимально возможной скоростью сети. Если буфер по каким либо причинам превысил вотерлинию(), например из-за медленной сети или обрыва соединения, то по умолчанию [zmq_send(3)](zmq_send.md) будет заблокирован и перестанет принимать сообщения. Но [zmq_send(3)](zmq_send.md) не будет отбрасывать сообщения.

Когда сокет ZMQ_CLIENT подключен к нескольким серверным сокетам ZMQ_SERVER, то исходящие сообщения будут отправляться по принципуround-robin(балансировки нагрузки). В свою очередь ZMQ_CLIENT получает сообщения от всех ZMQ_SERVER по принципу справедливой очереди(Fair-queue). Такое использование целесообразно только для протоколов без сохранения состояния.

ZMQ_CLIENT потокобезопасе и может используваться одновременно в нескольких потоках.

Обратите внимание, что ответ от ZMQ_SERVER получит тот клиентский сокет который первым вызовет libzmq:zmq_msg_recv. Если вы хотите получать ответ именно тем клиентом, кто отправил запрос, вам необходимо использовать подход с одним ZMQ_CLIENT сокетом на поток.

Сокеты ZMQ_CLIENT являются потокобезопасными. Они не принимают поддерживают параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это специально запрещает авторазбивку сообщения, чтобы вы сами докрутили интерфейс и позаботились о разбивке вашего/сборке вашего сообщения.

**Итоговые характеристики ZMQ_CLIENT**

|||
|--------|--------|
| Совместимость с типами сокетов 	| ZMQ_SERVER 	  |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Round-robin (балансировка)	  |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие беззвучного режима			| Бликоровка      |

#### ZMQ_SERVER

Сокет ZMQ_SERVER общается с ZMQ_CLIENT сокетами. Сокет ZMQ_SERVER только отвечает на запросы от ZMQ_CLIENT, которые всегда инициируют обмен.
Каждое отправленное сообщение имеет routing_id - беззнаковое 32-битное число. Приложение может получить енр при помощи [zmq_msg_routing_id(3)](zmq_msg_routing_id.md). Чтобы отправить сообщение пиру ZMQ_CLIENT, приложение должно сначала установить routing_id для сообщения исползуя [zmq_msg_set_routing_id(3)](zmq_msg_set_routing_id.md).

Если routing_id не указан или указывает на отключенного пира, то вызов метода отправки развалится с ошибкой EHOSTUNREACH. Если буфер исходящих сообщений для клиентского пира переполнен, вызов отправки будет блокирован, за исключением случая когда указан параметр ZMQ_DONT_WAIT, в таком случае мы получим ошибку EAGAIN. Сокет ZMQ_SERVER в обоих случаях не отбрасывает сообщения.

Сокет ZMQ_SERVER является потокобезопасным. Он не поддерживает параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это ограничение наложено специально, чтобы вы подумали сами как будет организована реализация разбивки и сборки сообщений.

**Итоговые характеристики ZMQ_SERVER**

|||
|--------|--------|
| Совместимость с типами сокетов  |	ZMQ_CLIENT |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Читайте текст   |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие беззвучного режима			| Бликоровка или ошибка EAGAIN |


### Паттерн радио-антенна (Radio-dish pattern)
Паттерн радио антненна предназначен для рассылки сообщений один-ко-многим от одного издателя ко множеству подписок по типу fanout(прим. терминология взята от amqp).

Радио антенна использует группы (а Pub-sub использует темы), сокеты "Антенны" согут подписаться на группу и получать сообщения только этой группы. Группы это строки с замыкающим null, длинна которых не превышает 16 символов включая замыкающий null. Мы собераемся увеличить это количество до 40 включая null.

Радио антенна фильтрует группы по точному совпадению в то время как pub-sub(издатель-подписчик), фильтрует свои темы по префиксному типу.

**Внимание! Паттерн радио-антенна на стадии разработки.**

Паттерн радио-антенна призван сменить устаревший петтерн pub-sub(издатель-подписчик).

### ZMQ_RADIO

Сокет ZMQ_RADIO используется издателем для мульти рассылки сообщений. Каждое сообщение пренадлежит какой-то группе и определяется методом [zmq_msg_set_group(3)](zmq_msg_set_group.md). Сообщения отсыдается всем членам этой группы. Для данного типа сокетов не реализована функция [zmq_recv(3)](zmq_recv.md), так как осуществляет только рассылку.

Данный тип сокета никогда не блокирует отправку сообщений. Если произойдет переполнение буфера очереди какого-то из клиентов, то все сообщения после этого будут просто отбрасываться до тех пор пока буфер не освободится.

Сокет ZMQ_RADIO является потокобезопасным. Он работает только с простыми сообщениями и не поддерживает параметр ZMQ_SNDMORE.

**Итоговые характеристики ZMQ_RADIO**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_DISH |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_DISH

Сокет ZMQ_DISH используется *подписчиком* для подписки на группы сообщений публикуемых *радио*. Изначально ZMQ_DISH не подписан на какие-либо группы, для подписки на какую-либо группу используйте [zmq_join(3)](zmq_join.md). Для получения подписок используйте [zmq_msg_group(3)](zmq_msg_group.md). Функция zmq_send() не реализована для данного типа сокетов.

Сокет ZMQ_RADIO является потокобезопасным. Он работает только с простыми сообщениями и не поддерживает параметр ZMQ_SNDMORE.

**Итоговые характеристики ZMQ_RADIO**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_RADIO |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение |
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|

## Паттерн издатель-подписчик (Publish-subscribe).

Паттерн издатель-подписчик предназначен для рассылки сообщений один-ко-многим от одного издателя ко множеству подписок по типу fanout(прим. терминология взята от amqp).

Паттерн издатель-подписчик формализован вот тут [http://rfc.zeromq.org/spec:29](http://rfc.zeromq.org/spec:29).

### ZMQ_PUB

Сокет **ZMQ_PUB** используется для рассылки данных. Отправленные сообщения доставляются по типу fan-out всем подключенным пирам. Данный тип сокета не поддерживает получение данных и не реализовывает функцию zmq_recv(3).

Данный тип сокета никогда не блокирует отправку сообщений. Если произойдет переполнение буфера очереди какого-то из клиентов, то все сообщения после этого будут просто отбрасываться до тех пор пока буфер не освободится.

**Итоговые характеристики ZMQ_PUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_SUB, ZMQ_XSUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_SUB

Тип сокета **ZMQ_SUB** используется подписчиком для подписки на сообщения отправленные издателем. Изначально сокет не подписан ни на какие сообщения, чтобы подписаться на какое-то сообщение используйте метод [zmq_setsockopt(3)](zmq_setsockopt.md) с параметром **ZMQ_SUBSCRIBE**. Сокет **ZMQ_SUB** не отправляет никакие сообщения и не реализует функццию zmq_send().

**Итоговые характеристики ZMQ_SUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUB, ZMQ_XPUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение |
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|

### ZMQ_XPUB

По факту тоже самое, что и **ZMQ_PUB**, за исключение того, что можно получать сообщения о подписке/отписе от пиров. Сообщение подписки - это байт 1 (для подписок) или байт 0 (для отписок), за которым следует тело подписки. Сообщения без префикса sub / unsub также принимаются, но не влияют на статус подписки.

Основным если не единственным применение **ZMQ_XPUB** + **ZMQ_XSUB** это создание возможности получать одним подписчиком сообщения от нескольких издателей. По факту реализация проксирования и ничего больше.

**Итоговые характеристики ZMQ_XPUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_SUB, ZMQ_XSUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Отправка сообщений, получение сообщений подписки |
| Маршрутизация исходящих сообщений | fanout   |
| Маршрутизация входящих сообщений  | N/A|
| Действие беззвучного режима			| Отбрасывание сообщений |

### ZMQ_XSUB

По факту тоже самое, что и **ZMQ_SUB**, за исключение того, что для подписки необходимо отправлять сообщения. Сообщение подписки - это байт 1 (для подписок) или байт 0 (для отписок), за которым следует тело подписки. Сообщения без префикса sub/unsub также принимаются, но не влияют на статус подписки.

Основным если не единственным применение **ZMQ_XPUB** + **ZMQ_XSUB** это создание возможности получать одним подписчиком сообщения от нескольких издателей. По факту реализация проксирования и ничего больше.

**Итоговые характеристики ZMQ_XSUB**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUB, ZMQ_XPUB |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Получение сообщений, отправка сообщений подписки|
| Маршрутизация исходящих сообщений | N/A   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|
| Действие беззвучного режима			| Отбрасывание сообщений |

## Паттерн конвейер (Pipeline pattern)

Шаблон конвейер используется для доставки сообщений к нодам по конвейеру. Данные постоянно движутся, как по конвейеру и каждый этап коневейера связан хотя бы с одной нодой. Когда к конвейеру подключено несколько нод сообщения распределяются по принципу round-robin(балансировки нагрузки).

Конвейер описан на странице [http://rfc.zeromq.org/spec:30.](http://rfc.zeromq.org/spec:30)

### ZMQ_PUSH

Тип сокета ZMQ_PUSH используется для отправки сообщений на конвейерную ленту. Сообщения распределяются между всеми *нодами* подключенными к ленте конвейера по принципу round-robin(балансировки нагрузки). Лента конвейера односторонняя и метод zmq_recv() для этого сокета не реализован.

Когда сокет входит в беззвучный режим, по причине того, что у всех подключенных сокетов была превышена вотерлиния или просто нет подключенных клиентов, функция [zmq_send(3)](zmq_send) блокируется до тех пор пока не пойвится способный принимать сообщение клиент. Сообщения не отбрасываются.

**Итоговые характеристики ZMQ_PUSH**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PULL |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только отправка|
| Маршрутизация исходящих сообщений | балансировки нагрузки Round-robin   |
| Маршрутизация входящих сообщений  | отсутствует|
| Действие беззвучного режима		| блокировка |

### ZMQ_PULL

Тип сокета ZMQ_PULL используется для получения сообщения с ковейера, которые распределяются по принципу справедливая очередь (Fair-queued). Реализация метода zmq_send() для этого типа сокета отсутствует.

**Итоговые характеристики ZMQ_PULL**

|||
|--------|--------|
| Совместимость с типами сокетов    | ZMQ_PUSH |
| Направление обмена 				| Двусторонний    |
| Паттерн получения/отправки		| Только получение|
| Маршрутизация исходящих сообщений | отсутствует   |
| Маршрутизация входящих сообщений  | Справедливая очередь (Fair-queued)|
| Действие беззвучного режима		| блокировка |

## Возвращаемое значение

## Ошибки

## Пример

## Смотрите также

## Authors
Страница написана сообществом ØMQ. Для внесения измененй ознакомьтесь с политикой для контрибьюторов ØMQ на страницу [http://www.zeromq.org/docs:contributing.](http://www.zeromq.org/docs:contributing)
Перевел Сарицкий Роман <saritskiy.r@gmail.com>