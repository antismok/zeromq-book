zmq_socket

## Краткое описание
zmq_socket - Создает сокет ØMQ

## Синопсис
```
void *zmq_socket (void *context, int type);
```

## Описание
Функция zmq_socket создает сокет в указанном контексте и возвращает дескриптов внось созданного сокета. Аргумент type указывает тип сокета, который определяет семантику связи через сокет.
Изначально сокет не связан и не указывает ни на какие конечные точки. Чтобы начать обмен сообщениями, сокет должен быть подключени хотя бы к одной конечной точке при помощи [zmq_connect(3)](zmq_connect.md), или начать прослушку при помощи [zmq_bind(3)](zmq_bind.md).

**Ключевый отличия от обычных сокетов.**
Традиционные сокеты предоставляют два вида интерфейсов для пересылки данных. Первый это надежный синхронный потоковый интерфейс(**SOCK_STREAM**), второй это не надежный датаграмный интерфейс(**SOCK_DGRAM**). ØMQ сокеты представляют собой абстракцию асинхронной очереди сообщений с точной семантикой очереди в зависимости от используемого типа сокета. Там где общепринятые сокеты передают набор байт и датаграмм, сокеты ØMQ предают дискретные сообщения.


Управление асинхронностью, соединениями, переподключениями, эффективной отправкой сообщений, делается под капотом ØMQ и не требуют вашего вмешательства. Кроме того сообщения могут быть поставлены в очередь на отправку без установленного соединения с конечным узлом.

Традиционные сокеты могут устанавливать только соединение один-к-одному(два пира), один-ко-многим (один сервер и много клиентов) и в редких случаях широковещательные(broadcast). У ØMQ же все сокеты, за исключением ZMQ_PAIR, могут быть одновременно подключены к нескольким конечным точкам с помощью zmq_connect(), одновременно принимая входящие соединения от нескольких конечных точек, подвешенных на сокет, с помощью zmq_bind(), что позволяет устанавливать отношения «многие ко многим».

ØMQ имеет потокобезопасные сокеты, а также не потокобезопасные. Приложения НЕ ДОЛЖНЫ использовать не потокобезопасные типы сокетов в многопоточных приложениях, за исключением миграции с однопоточных на многкопоточны и в этом случае все равно необходимо предусмотреть защитный слой для памяти такой как "full fence".

Потокобезопасные сокеты: \* ZMQ_CLIENT \* ZMQ_SERVER \* ZMQ_DISH \* ZMQ_RADIO \* ZMQ_SCATTER \* ZMQ_GATHER

**Типы сокетов** 
Ниже представлены типы сокетов ØMQ которые сгруппированы по *шаблонам передачи сообщений*.

#### Шаблон клиент-сервер. (Client-server pattern)

Шаблон клиент-сервер используется для взаимодействия между сервером и одним или несколькими клиентами. Первое действие всегда за клиентом, после чего оба могут обмениваться асинхронными сообщениями.

Формат определен на странице [https://rfc.zeromq.org/spec:42/C4/](https://rfc.zeromq.org/spec:42/C4/).

**Примечание:** Этот шаблон предназначен прийти на замену шаблону ZMQ_DEALER/ZMQ_ROUTER для построения клиент-серверных архитектур, а также ZMQ_REP/ZMQ_REQ для архитектур запрос-ответ.

#### ZMQ_CLIENT
Сокет ZMQ_CLIENT начинает общение с серверным сокетом ZMQ_SERVER. Подключиться может любой пир, хотя обычно рекомендуется сначала начать прослушку ZMQ_SERVER и полключить сокет ZMQ_CLIENT. Если сокет ZMQ_CLIENT уже установил соединенине, то [zmq_send(3)](zmq_send.md),будет принимать сообщения, класть их в свою внутреннюю очередь и отправлять их так с максимально возможной скоростью сети. Если буфер по каким либо причинам превысил вотерлинию(), например из-за медленной сети или обрыва соединения, то по умолчанию [zmq_send(3)](zmq_send.md) будет заблокирован и перестанет принимать сообщения. Но [zmq_send(3)](zmq_send.md) не будет отбрасывать сообщения.

Когда сокет ZMQ_CLIENT подключен к нескольким серверным сокетам ZMQ_SERVER, то исходящие сообщения будут отправляться по принципуround-robin(балансировки нагрузки). В свою очередь ZMQ_CLIENT получает сообщения от всех ZMQ_SERVER по принципу справедливой очереди(Fair-queue). Такое использование целесообразно только для протоколов без сохранения состояния.

ZMQ_CLIENT потокобезопасе и может используваться одновременно в нескольких потоках.

Обратите внимание, что ответ от ZMQ_SERVER получит тот клиентский сокет который первым вызовет libzmq:zmq_msg_recv. Если вы хотите получать ответ именно тем клиентом, кто отправил запрос, вам необходимо использовать подход с одним ZMQ_CLIENT сокетом на поток.

Сокеты ZMQ_CLIENT являются потокобезопасными. Они не принимают поддерживают параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это специально запрещает авторазбивку сообщения, чтобы вы сами докрутили интерфейс и позаботились о разбивке вашего/сборке вашего сообщения.

**Итоговые характеристики ZMQ_CLIENT**

|||
|--------|--------|
| Совместимость с типами сокетов 	| ZMQ_SERVER 	  |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Round-robin (балансировка)	  |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие тихого режима			| Бликоровка      |

#### ZMQ_SERVER

Сокет ZMQ_SERVER общается с ZMQ_CLIENT сокетами. Сокет ZMQ_SERVER только отвечает на запросы от ZMQ_CLIENT, которые всегда инициируют обмен.
Каждое отправленное сообщение имеет routing_id - беззнаковое 32-битное число. Приложение может получить енр при помощи [zmq_msg_routing_id(3)](zmq_msg_routing_id.md). Чтобы отправить сообщение пиру ZMQ_CLIENT, приложение должно сначала установить routing_id для сообщения исползуя [zmq_msg_set_routing_id(3)](zmq_msg_set_routing_id.md).

Если routing_id не указан или указывает на отключенного пира, то вызов метода отправки развалится с ошибкой EHOSTUNREACH. Если буфер исходящих сообщений для клиентского пира переполнен, вызов отправки будет блокирован, за исключением случая когда указан параметр ZMQ_DONT_WAIT, в таком случае мы получим ошибку EAGAIN. Сокет ZMQ_SERVER в обоих случаях не отбрасывает сообщения.

Сокет ZMQ_SERVER является потокобезопасным. Он не поддерживает параметры ZMQ_SNDMORE при отправке и ZMQ_RCVMORE при получении. Это ограничение наложено специально, чтобы вы подумали сами как будет организована реализация разбивки и сборки сообщений.

**Итоговые характеристики ZMQ_SERVER**

|||
|--------|--------|
| Совместимость с типами сокетов  |	ZMQ_CLIENT |
| Направление обмена 				| Двусторонний    |
| Шаблон получения/отправки			| Без ограничений |
| Маршрутизация исходящих сообщений | Читайте текст   |
| Маршрутизация входящих сообщений  | Fair-queued (справедливая очередь)|
| Действие тихого режима			| Бликоровка или ошибка EAGAIN |


### Шаблон радио-антенна (Radio-dish pattern)

## Возвращаемое значение

## Ошибки

## Пример

## Смотрите также

## Authors
Страница написана сообществом ØMQ. Для внесения измененй ознакомьтесь с политикой для контрибьюторов ØMQ на страницу [http://www.zeromq.org/docs:contributing.](http://www.zeromq.org/docs:contributing)
Перевел Сарицкий Роман <saritskiy.r@gmail.com>