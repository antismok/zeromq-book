# ØMQ - The Guide
# РУКОВОДСТВО

### Pieter Hintjens главный исполнительный директор iMatix.
Для всех комментариев и ошибок, пожалуйста используйте [трекер](https://github.com/imatix/zguide/issues). Данная версия руководства написана по последней стабильной версии ZeroMQ (3.2).
Если вы используете старую версию ZeroMQ то некоторые данные могуть различаться.
Руководство предоставляет примеры на Си, но так же PHP, Python, Lua, and Haxe. Так же мы перевели большинство примеров на C++, C#, CL, Delphi, Erlang, F#, Felix, Haskell, Java, Objective-C, Ruby, Ada, Basic, Clojure, Go, Haxe, Node.js, ooc, Perl, and Scala.


## Предисловие

### Кратко о ZeroMQ

ZeroMQ, так же известная как  ØMQ, 0MQ, zmq, или Зера, является встраиваемой сетевой библиотекой, но чаще всего  используется как мультипоточный фреймворк. Она предоставляет сокеты для передачи атомарных сообщений поверх различных транспортных уровней, таких как межпроцессное взаимодействие(IPC), TCP и широковещательная рассылка (multicast). Вы можете подключить сокеты М-М(многие ко многим) используя паттерны такие как  fan-out(сообщение передается во все прицепленные к ней очереди), pub-sub(издатель-подписчик), task distribution(распределение задач), и request-reply(запрос-ответ).Скорости Зеры достаточно, чтобы построить высоконагруженные кластеры. Асинхронная модель ввода/вывода развязывает руки для построения многопоточных приложений, построенных как многопоточные задачи. Поддерживает множество языков программирования и запускается на большинстве популярных операционных системах. ZeroMQ от [iMatix](http://www.imatix.com/) распространяется под лицензией LGPLv3 с открытым исходным кодом.

### Как все начиналось (How It Began)

Мы взяли обычные tcp сокеты, добавили в них смесь радиоактивных изотопов похищенных из секретного советского проекта атомных исследований, бомбанули по нему космическими лучами 1950-х годов и отдали его в руки обдолбанного автора комиксов с фетишем обтягивающего трико. Да сокеты ZeroMQ это супергерои которые призваны спасти сетевой мир.
###### Рисунок 1: Страшная катастрофа.
![](https://github.com/imatix/zguide/raw/master/images/fig1.png)

### Дзен ZeroMQ (The Zen of Zero)

Ноль в наименовании ZeroMQ означает компромисс. С одной стороны такое странное название снижает позиции в google и twitter. С другой стороны это раздражает некоторых датчан которые пишут нам такие вещи как "ØMG røtfl", и «Ø не забавный нулевой!» и «Rødgrød med fløde!», что, по-видимому, является оскорблением, которое означает «пусть ваши соседи станут прямыми потомками Гренделя!» Вроде бы справедливый обмен.

На самом деле ноль в наименовании ZeroMQ означает "нулевой брокер" и (как можно быстрее) "нулевая задержка". С того времени это привело к зарождению новой терминологии: Нулевое администрирование, нулевая стоимость, ноль отходов. В более общем плане «ноль» относится к культуре минимализма, концепции которой придерживается проект. Мы подкрутили мощность, удаляя сложность, а не функционал.

### Для кого эта книга (Audience)

Эта книга написана для профессиональных программистов, кто хочет узнать как создавать огромные распределенные системы доминирующие по производительности. Надеемся вы знаете и умеете читать код на СИ, так как большинство примеров в книге приведены на СИ, хотя ZeroMQ может быть применен во множестве языков. Предполагается что вам нужен лучший результат за меньшие деньги, иначе вы разочаруетесь компромиссами предоставленными ZeroMQ. Помимо базовых вещей мы попытаемся представить все концепции сетевых и распределенных вычислений, они вам понадобятся при работе с ZeroMQ.

### Благодарности. (Acknowledgements)

Спасибо Andy Oram за возможность выхода книги [O'Reilly](http://shop.oreilly.com/product/0636920026136.do) и редактирования этого текста.

Спасибо Bill Desmarais, Brian Dorsey, Daniel Lin, Eric Desgranges, Gonzalo Diethelm, Guido Goldstein, Hunter Ford, Kamil Shakirov, Martin Sustrik, Mike Castleman, Naveen Chawla, Nicola Peduzzi, Oliver Smith, Olivier Chamoux, Peter Alexander, Pierre Rouleau, Randy Dryburgh, John Unwin, Alex Thomas, Mihail Minkov, Jeremy Avnet, Michael Compton, Kamil Kisiel, Mark Kharitonov, Guillaume Aubert, Ian Barber, Mike Sheridan, Faruk Akgul, Oleg Sidorov, Lev Givon, Allister MacLeod, Alexander D'Archangel, Andreas Hoelzlwimmer, Han Holl, Robert G. Jakabosky, Felipe Cruz, Marcus McCurdy, Mikhail Kulemin, Dr. Gergő Érdi, Pavel Zhukov, Alexander Else, Giovanni Ruggiero, Rick "Technoweenie", Daniel Lundin, Dave Hoover, Simon Jefford, Benjamin Peterson, Justin Case, Devon Weller, Richard Smith, Alexander Morland, Wadim Grasza, Michael Jakl, Uwe Dauernheim, Sebastian Nowicki, Simone Deponti, Aaron Raddon, Dan Colish, Markus Schirp, Benoit Larroque, Jonathan Palardy, Isaiah Peng, Arkadiusz Orzechowski, Umut Aydin, Matthew Horsfall, Jeremy W. Sherman, Eric Pugh, Tyler Sellon, John E. Vincent, Pavel Mitin, Min RK, Igor Wiedler, Olof Åkesson, Patrick Lucas, Heow Goodman, Senthil Palanisami, John Gallagher, Tomas Roos, Stephen McQuay, Erik Allik, Arnaud Cogoluègnes, Rob Gagnon, Dan Williams, Edward Smith, James Tucker, Kristian Kristensen, Vadim Shalts, Martin Trojer, Tom van Leeuwen, Hiten Pandya, Harm Aarts, Marc Harter, Iskren Ivov Chernev, Jay Han, Sonia Hamilton, Nathan Stocks, Naveen Palli, и Zed Shaw за их участие в этой работе.



## ГЛАВА 1 - ОСНОВЫ

### Исправление мира (Fixing the World)

Как можно описать ZeroMQ? Некоторые из нас начинают перечислять все плюшки которые предоставляет Зера. По сути это сокеты на стероидах. Это как почтовые ящики с маршрутизацией. Это быстро! Другие попытаются поделиться своим моментом просветления, что по началу было сложно изменить в голове устоявшееся понимание сокетов, но однажды приходит понимание того, что обычные сокеты и сокеты зеры не одно и тоже. Все становится проще. Сложность уходит. Разум просветляется. Кто-то попытается объяснить на примере сравнения. Это проще, легковеснее, но все еще нам знакомо.

Программирование это наука завуалированная под искусство, так как большинство из нас не понимает программирования на физическом уровне и вообще редко когда изучает этот аспект. Физика программного обеспечения это не алгоритмы, структуры данных, языки и абстракции. Это просто инструменты, которые мы делаем, используем, а затем выбрасываем. Реальная физика ПО это физика человека - в частности наши физические ограничения, когда дело касается сложности ПО, а также наше решение работать в команде, чтобы разделить сложную реализацию на более мелкие кусочки. Наука программирования состоит в том, чтобы создать конструктивные блоки, легкие в понимании и использовании людьми, тогда и только тогда люди смогут решать огромные проблемы.

Мы живем в общающемся мире, когда все между собой контактирует и современное программное обеспечение должно подстраиваться под этот мир. Создание тяжеловесных решений будущего, создает очень связный код и требует мультипоточности. Это больше не соответствует заповеди "чистого кода". Код должен взаимодействовать с кодом. Код должен быть говорящим, дружелюбным и легко подключаемым. Код должен стартовать как человеческий мозг, триллионами нейронных нитей с сообщениями в каждой из них, с громадной параллельной сетью, не имеющей центра управления, не имеющей точки отказа, но способный решать чрезвычайно сложные задачи. И это не случайно, что будущее программного кода выглядит как человеческий мозг, поскольку конечные точки каждой сети, на некотором уровне являются человеческим мозгом.

Поработайте с потоками, протоколами, или сетями и вы поймете что это практически невозможно. Это мечта. Даже подключение всего нескольких программ через несколько сокетов, на деле довольно неприятное занятие. Триллионы? Цена за такое даже невообразима. Связать компьютеры настолько сложно, что это породило много миллиардные бизнесы, по созданию сетевого программного обеспечения.

По-этому мы живем в мире где железо намного опережает наши способности его обуздать. Во время кризиса 80х годов, когда даже такие тимлиды как Фред Брукс не верили в существование "серебряной пули", способной поднять планку совершенства хотя бы на единицу в производительности, надежности и простоте.

Брукс упустил из виду открытое ПО, помогающее справится с этим кризисом, подтолкивающее нас более эффективно делиться опытом. Сегодня нас настиг другой кризис ПО, но мы про это промолчим. Только большие, богатые фирмы могут позволить себе разработку общающихся приложений. Существует облако, но оно закрытое. Наши персональные данные перекочевывают в облака, к которым у нас нет доступа и которым мы не конкуренты. Кто владеет нашими соцсетям? Это похоже на революцию мейнфреймов в обратном направлении.

Мы оставим политическую философию для другой книги. Дело в том, что хоть интернет и предполагает большой потенциал массового общающегося кода, реальность такова, что для большинства такая задача непреодолима, и большие интересные задачи (в здравоохранении, образовании, экономике, транспорта и тд.) остаются не решенными, так как нет возможности это все связать, нет возможности продумать и работать совместно над этими проблемами.

Было множество попыток решения проблем общения между кодом. Существуют тысячи спецификаций IETF, каждая из которых разрешает часть головоломки. Для разработчиков приложений HTTP - это пожалуй одно из решений достаточно простое для работы, но порождающую проблему куда хуже, поощряя разработчиков и архитекторов думать большими сервисами и тонкими тупыми клиентами.

Сегодня все еще соединяют приложения посредством чистых UDP и TCP, закрытых протоколов, http и веб-сокетов. Это порождает головную боль для разработчиков, медлительность, сложность в масштабировании, в также централизацию. Распределенные архитектуры P2P в основном предназначены для баловства, а не для работы. Сколько приложений использует Skype или Bittorrent для обмена данными?

Это возвращает нас к изучению программирования. Чтобы исправить мир, нам нужно две вещи. Первая, решить проблему того, чтобы любой код мог взаимодействовать с любым кодом. Вторая, упаковать это в такой инструмент, который помогал бы легко конструировать блоки кода, простые для понимания и использования.

Звучить до смешного просто. Может так оно и есть. Вот и все.

## Соглашения. (Starting Assumptions)

Договоримся, что вы используете хотя бы версию Зеры 3.2. Договоримся что в примерах мы используем ос линукс или подобную. Предположим вы умеете читать код на Си, чтобы более или менее понимать примеры. Договоримся что когда мы пишем обобщенные константы PUSH или SUBSCRIBE имеются ввиду ZMQ_PUSH или ZMQ_SUBSCRIBE, что зависит от языка программирования и вы сами подставите их в свой.

### Примеры (Getting the Examples)

Примеры находятся в публичном [git репозитории](https://github.com/imatix/zguide). Простейшим путем будет просто клонировать их к себе в директорию.

`git clone --depth=1 git://github.com/imatix/zguide.git`

Далее в своей директории вы найдете примеры для различных языков программирования. Если все же ваш язык отсутствует, то мы поощряем предоставление примеров для него. Таким образом зародились эти примеры, спасибо всем за приложенные к этому усилия. Все примеры распространяются по лицензии MIT/X11.

### Просите и дано вам будет (Ask and Ye Shall Receive).

Давайте же уже перейдем к коду. Разумеется мы начнем с Hello World. Для начала создадим клиента и сервер. Клиент отправляет "HELLO" на сервер и получает в ответ "WORLD" (рис 2).
В примере блок кода сервера на языке СИ. Он открывает сокет Зеры на порту 5555, читает из него запросы и отвечает "WORLD" на каждый из них.

*сервер Hello World на СИ*
```
//  Hello World server

#include <zmq.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

int main (void)
{
    //  Socket to talk to clients
    void *context = zmq_ctx_new ();
    void *responder = zmq_socket (context, ZMQ_REP);
    int rc = zmq_bind (responder, "tcp://*:5555");
    assert (rc == 0);

    while (1) {
        char buffer [10];
        zmq_recv (responder, buffer, 10, 0);
        printf ("Received Hello\n");
        sleep (1);          //  Do some 'work'
        zmq_send (responder, "World", 5, 0);
    }
    return 0;
}```

Пара сокетов типа REQ-REP(запрос-ответ) являются последовательно-зависимой. Клиент в цикле сначала отправляет запрос [zmq_send()](http://api.zeromq.org/3-2:zmq_send) и только после этого ждет ответ [zmq_recv()](http://api.zeromq.org/3-2:zmq_recv). Использование другой последовательности (к примеру отправка подряд двух сообщений) приведет к тому что функция вернет -1. Аналогичным образом сервисы сначала слушают запрос [zmq_recv()]http://api.zeromq.org/3-2:zmq_recv) и только после этого отправляют на него ответ [zmq_send()](http://api.zeromq.org/3-2:zmq_send).

Зера использует Си и это так же основной язык для написания примеров. Если вы читаете это на сайте то внизу будут ссылки для примеров переведенных на разные языки. Теперь давайте сравним аналогичный сервер на С++:

###### *hwserver.cpp: Hello World server*
```
//
//  Hello World server in C++
//  Binds REP socket to tcp://*:5555
//  Expects "Hello" from client, replies with "World"
//
#include <zmq.hpp>
#include <string>
#include <iostream>
#ifndef _WIN32
#include <unistd.h>
#else
#include <windows.h>

#define sleep(n)    Sleep(n)
#endif

int main () {
    //  Prepare our context and socket
    zmq::context_t context (1);
    zmq::socket_t socket (context, ZMQ_REP);
    socket.bind ("tcp://*:5555");

    while (true) {
        zmq::message_t request;

        //  Wait for next request from client
        socket.recv (&request);
        std::cout << "Received Hello" << std::endl;

        //  Do some 'work'
        sleep(1);

        //  Send reply back to client
        zmq::message_t reply (5);
        memcpy (reply.data (), "World", 5);
        socket.send (reply);
    }
    return 0;
}```

###### * Рисунок 2. Запрос-ответ (Request-Reply)*
![](https://github.com/imatix/zguide/raw/master/images/fig2.png)

Как вы можете убедиться API для языков СИ и С++ аналогичны. На языке таком как php или java, мы можем скрыть большинство реализации и сделать код еще более легким и читаемым:

###### * Пример 3. сервер Hello World на php (hwserver.php) *

```
<?php

/*
 *  Hello World server
 *  Binds REP socket to tcp://*:5555
 *  Expects "Hello" from client, replies with "World"
 *  @author Ian Barber <ian(dot)barber(at)gmail(dot)com>
 */

$context = new ZMQContext(1);

//  Socket to talk to clients
$responder = new ZMQSocket($context, ZMQ::SOCKET_REP);
$responder->bind("tcp://*:5555");

while (true) {
    //  Wait for next request from client
    $request = $responder->recv();
    printf ("Received request: [%s]\n", $request);

    //  Do some 'work'
    sleep (1);

    //  Send reply back to client
    $responder->send("World");
}```

###### Пример сервера на других языках:
[ C++ ](http://zguide.zeromq.org/cpp:hwserver)|[ C# ](http://zguide.zeromq.org/cs:hwserver)|[ Clojure ](http://zguide.zeromq.org/clj:hwserver)|[ CL ](http://zguide.zeromq.org/lisp:hwserver)|[ Delphi ](http://zguide.zeromq.org/dpr:hwserver)|[ Erlang ](http://zguide.zeromq.org/es:hwserver)|[ F# ](http://zguide.zeromq.org/fsx:hwserver)|[ Felix ](http://zguide.zeromq.org/flx:hwserver)|[ Go ](http://zguide.zeromq.org/go:hwserver)|[ Haskell ](http://zguide.zeromq.org/hs:hwserver)|[ Haxe ](http://zguide.zeromq.org/hx:hwserver)|[ Lua ](http://zguide.zeromq.org/lua:hwserver)|[ Node.js ](http://zguide.zeromq.org/js:hwserver)|[ Objective-C ](http://zguide.zeromq.org/m:hwserver)|[ Perl ](http://zguide.zeromq.org/pl:hwserver)|[ PHP ](http://zguide.zeromq.org/php:hwserver)|[ Python ](http://zguide.zeromq.org/py:hwserver)|[ Q ](http://zguide.zeromq.org/q:hwserver)|[ Racket ](http://zguide.zeromq.org/rkt:hwserver)|[ Ruby ](http://zguide.zeromq.org/rb:hwserver)|[ Scala ](http://zguide.zeromq.org/scala:hwserver)|[ Tcl ](http://zguide.zeromq.org/tcl:hwserver)|[ Ada | Basic | Java | ooc ](http://zguide.zeromq.org/main:translate)

###### Пример клиента на других языках:
[ C++ ](http://zguide.zeromq.org/cpp:hwclient)|[ C# ](http://zguide.zeromq.org/cs:hwclient)|[ Clojure ](http://zguide.zeromq.org/clj:hwclient)|[ CL ](http://zguide.zeromq.org/lisp:hwclient)|[ Delphi ](http://zguide.zeromq.org/dpr:hwclient)|[ Erlang ](http://zguide.zeromq.org/es:hwclient)|[ F# ](http://zguide.zeromq.org/fsx:hwclient)|[ Felix ](http://zguide.zeromq.org/flx:hwclient)|[ Go ](http://zguide.zeromq.org/go:hwclient)|[ Haskell ](http://zguide.zeromq.org/hs:hwclient)|[ Haxe ](http://zguide.zeromq.org/hx:hwclient)|[ Lua ](http://zguide.zeromq.org/lua:hwclient)|[ Node.js ](http://zguide.zeromq.org/js:hwclient)|[ Objective-C ](http://zguide.zeromq.org/m:hwclient)|[ Perl ](http://zguide.zeromq.org/pl:hwclient)|[ PHP ](http://zguide.zeromq.org/php:hwclient)|[ Python ](http://zguide.zeromq.org/py:hwclient)|[ Q ](http://zguide.zeromq.org/q:hwclient)|[ Racket ](http://zguide.zeromq.org/rkt:hwclient)|[ Ruby ](http://zguide.zeromq.org/rb:hwclient)|[ Scala ](http://zguide.zeromq.org/scala:hwclient)|[ Tcl ](http://zguide.zeromq.org/tcl:hwclient)|[ Ada | Basic | Java | ooc ](http://zguide.zeromq.org/main:translate)

Теперь это выглядит слишком просто, чтобы быть правдой, но не забывайте, что сокеты Зеры имеют суперсилы. Вы можете навешать на этот сервер тысячи клиентов и он продолжит быстро и припеваючи работать. Ради интереса запустите сначала клиента и только потом сервер. Смотри это все еще работает и не падает, задумайтесь на секунду почему так происходит.

Давайте кратко посмотрим как эти две программы действительно работают. Они создают контекст Зеры и сокеты для работы. Не задумывайтесь о значении этих терминов. Скоро вы все поймете. Сервер навешивает свой сокет REP(ответ) на порт 5555. Сервер в цикле ожидает запроса, и отвечает на каждый. Клиент отправляет запрос и ожидает на него ответа. Если вы перезапустите сервер, клиент сам не поднимется. Поднятие после сбоят так просто не пройдет. Создание отказоустойчивых соединений типа запрос-ответ(request-reply) довольно сложный процесс и мы до него еще дойдем когда будем рассматривать "надежные паттерны ответ-запрос ("Reliable Request-Reply Patterns").

Многое происходит за кадром, но для нас программистов важно чтобы код был красивым, аккуратным и не падал под нагрузками. Паттерн запрос-ответ(request-reply), возможно простейший способ использования Зеры. Это отражение RPC и классической клиент-серверной модели.

### СНОСОЧКА ПРО СТРОКИ(A Minor Note on Strings)

Зера ничего не знает о том что за данные вы отправляете, за исключением размера в байтах. Это означает что вся ответственность за форматирование и безопасность целиком на вас. Для отправки объектов и структур данных используйте специализированные библиотеки такие как "Протокол Буфферов". Но так же не забывайте позаботиться и о простых строковых данных.
В СИ и некоторых других языках строки оканчиваются нулевым байтом. Мы должны отправить строку типа "HELLO" вместе с закрывающим нулевым байтом

zmq_send (requester, "Hello", 6, 0);

Однако если вы используете другой язык, то можно не заботиться о нулевом байте. К примеру отпрака той же строки на языке Python, выглядит вот так:

socket.send ("Hello")

Тогда то что будет отправлено это длинна(один байт определяющий длинну) и содержимое строки в виде отдельных ее символов(рис 3).
И если вы читаете это на стороне кода СИ вы получите нечто выглядещее как строка (если повезет все пять байт выстроятся как надо), но ею не являющейся. Когда ваши клиент серверные приложения не имеют согласованного формата строк, вам придется выуживать данные. 

Когда вы получаете данные на строне языка СИ, нельзя безоговорочно доверять тому что строка будет корректно завершена mull байтом. Каждый раз при приеме сообщения вам нужно выделить память под это строку с учетом закрывающего байта, скопировать туда строку и самостоятельно завершить строку null байтом. В таком случае давайте установим правило - Строки Зеры зависимы от длинны и не имеют закрывающего null байта. В лучшем случае Зера обработает кусок сообщения как показано на рисунке выше - с учетом байта длинны и последующих за ним байт.

Вот что необходимо сделать на стороне кода на СИ чтобы получить строку и корректно ее обработать для превращения в корректную строку.

// Receive 0MQ string from socket and convert into C string
// Chops string at 255 chars, if it's longer
static char *
s_recv (void *socket) {
 char buffer [256];
 int size = zmq_recv (socket, buffer, 255, 0);
 if (size == -1)
 return NULL;
 if (size > 255)
 size = 255;
 buffer [size] = 0;
 return strdup (buffer);
}

Этот код можно превратить во вспомогательную функцию и подключать ее в заголовках. Собственно что и сделано в  zhelpers.h. Это поможет сделать разработку на Зере красивее и приятнее на языке СИ. Код слишком длинный чтобы его тут выплевывать, так что истинные фанатики СИ прочтут его на досуге(https://github.com/booksbyus/zguide/blob/master/examples/C/zhelpers.h).

### ВЕРСИОНИРОВАНИЕ.(Version Reporting)

Зера существует в нескольких версиях и если вы сталкнулись с какой то проблемой, то скорее всего это уже исправлено в следующей версии. Так что полезным трюком будет знать какую версию либы ви используете. Вот маленькая программа позволяющая определить текущую версию. 
Example 5. ØMQ version reporting (version.c)

### ПОЛУЧЕНИЕ СООБЩЕНИЯ.(Getting the Message Out)

Второй классический паттерн это односторонняя пепесылка, когда сервер отправляет обновления набору клиентов. Давайте посмотрим на пример в котором сервер отправляет обновления почтовых индексов, температуры и влажности. Будем генерировать произвольные значения, чтобы съэмулировать поведения погоды.

Пример сервера. Используем порт 5556 для приложения для клиента.

Example 6. Weather update server (wuserver.c)

Это нескончаемый широковещательный поток(рис.4)

Пример клиента который слушает все оповещения об изменениях и парсит их. По дефолту почтовый индекс будет для Нью Йорка.

Example 7. Weather update client (wuclient.c)

Обратите внимание что когда вы используете SUB сокет вы ДОЛЖНЫ установить подписчика используя функцию zmq_setsockopt() и тем самым подписаться как в примере. Если вы ни на что не подписались вы ничего не получите. Это частая ошибка для новичков. Подписчик может одновременно подписаться на множество каналов. И если обновление соответсвует любой из этих подписок то подписчик получит это сообщение. Так же есть возможность отписаться от любой подписки. Подписка чаще всего задается в виде человекочитаемой стоки, но это не жесткое ограничение. Дополнительно можно посмотреть в описании функции zmq_setsockopt().

Пара сокетов издатель-подписчик(PUB-SUB) является асинхронной. Клиент вызывает в цикле(или единажды если нужно) zmq_recv(). При попытке отправить сообщение по SUB сокету вызовет ошибку. Аналогично сервис вызывает zmq_send() когда это нужно, но не может вызвать zmq_recv() на сокете подписчика(PUB).

Теоретически Зере плевать кто слушает, а кто подключается к сокету. Однако на практике есть незадокументированные отличия, о которых мы поговорим позже. Сейчас просто слушаем PUB и подключаемся к SUB.

Еще одна важная вещь с сокетами типа подписчик-издатель которую нужно знать и учитывать. Вы не знаете когда подписчик начнет получить сообщения. Даже если вы сначала запустите подписчика и только после этого, выдержав паузу, запустите издателя, ПОДПИСЧИК ВСЕГДА ПРОПУСТИТ ПЕРВОЕ СООБЩЕНИЕ. Это случается потому что пока подписчик подключается(обычно это делается быстро, но не моментально), издатель уже может отправть сообщение. Поскольку множество людей натыкаются на этот казус, давайте остановимся на нем подробнее. Запомните что Зера выполняте асинхронное чтение и отправку в фоновом режиме. Предположим у нас есть два узла которые выполняются в следующем порядке.

* Подписчик подключается к конечной точке, получает сообщения и считает сколько он получил сообщений.
* издатель вешается на конечную точку и немедленно отправляет 1000 сообщений.

В такм случае подписчик скорее всего ничего не получит. Вы в замешательсве, проверяете что правильно указали параметры подключения, пробуете снова и опять ничего не получили. Создание TCP соединения требует подтверждения связи между конечными узлами, что требует какое то время, которое зависит от вашей сети  и количества хопов между конечными точками. За это время Зера уже отправит кучу сообщений. К примеру для установки канала требуется 5мс и этот же канал способен обрабатывать миллион сообщений в секунду. Когда подписчику требуется целых 5мс на установку соединения, издателю потребуется всего 1мс на отправку всей тысячи сообщений.

В глеве "Паттерны по сокетам" мы расскажем как синхронизировать издателя и подписчика таким образом чтобы сообщения не отправлялись пока не будет все подписчики не законектятся и будут готовы получать сообщения. Существует простой и тупейший способ заставить издателя подождать - поставить ему задержку. Не стоит так делать, то тупейший, не красивый и медленный способ. Подождите до галавы "Паттерны по сокетам" и вы все узнаете.

Существует еще один способ. Принять решение что наш поток данных бесконечный и подписчику плевать на то что приходило до его подключения. Как к примеру в нашем примере с погодными данными.

Клиент подписывается на рассылку почтовых индексов и собирает тысячу обновлений для почтовых индексов. Сервис может нагененировать 10 миллионов сообщений. Вы можете запустить клиента, потом сервис, и клиент продолжить работать. Вы можете перезапускать сервис когда вам вздумается и клиент продолжит работать. Когда подписчик соберет 1000 сообщений, он их обработает, выведет и завершится.

Некоторые аспекты по паттерну подписчик-издатель(pub-sub):

* Подписчик может подписываться на множество издателей единовременно. Данные будут приходить и чередоваться(справедливая очередь), таким образом что один издатель не будет заглушать другого.

* Если у издателя не будет подключенных подписчиков, он просто будет отбрасывать все сообщения.

* Если вы используете tcp соединение и подписчик тормозит то сообщения будут накапливаться в очереди у издателя. Как защитить издателей от переполнения такого рода, путем установки ограничения, рассмотрим позже.

* Начиная с Зеры версии 3 и выше, если вы используете протоколы tcp:// или ipc:// фильтрация происходит на стороне издателя. При использовании протокола epgm:// фильтрация происходит на стороне подписчика. В версиях со второй по третью вся фильтрация происходит на стороне подписчика.

Ниже показано сколько времени занимает получение и фильтрация 10 миллионов сообщений, на моем лэптопе с процессором intel i5 поколения 2011 года. Прилично но ничего особенного.

$ time wuclient
Collecting updates from weather server...
Average temperature for zipcode '10001 ' was 28F
real 0m4.470s
user 0m0.000s
sys 0m0.008s

### РАЗДЕЛЯЙ И ВЛАСТВУЙ (Divide and Conquer)

В качестве последнего примера (вы наверняка уже устали от кода и хотели бы вернуться к философствованию и обсуждению абстрактных норм), давайте произведем немного суперкомпьютеров. Наше суперкомпьютерное приожение является довольно типичной моделью параллельной обработки.

У нас есть: 
	* Вентилятор который создает задачи которые можно выполнять параллельно
	* Набор воркеров которые могут обрабатывать задачи.
	* Сток(имеется ввиду место куда попадают все данные), способный собираеть воедино данные от воркеров.

В действительности воркеры запускаются в быстродействующих контейнерах, может даже на графических процессорах для сложных расчетов. Вентилятор генерирует 100 задач, каждое из которых говорит воркеру спать определенное количество милисекунд.

Example 8. Parallel task ventilator (taskvent.c)

А вот пример воркера. Он получет сообщение, спит определенно количество секунд, после чего сообщяет что он закончил.

Example 9. Parallel task worker (taskwork.c)

А вот наше приложение для сбора результатов. Оно собирает данные от 100 задач и срачитывает как долго они выполнялись. Так мы сможе убедиться что задачи выполнялись параллельно, если воркеров было несколько.

Example 10. Parallel task sink (tasksink.c)

Среднее время выполнения 5 сек. Когда мы запустим 1,2 или 4 воркера мы получим результаты схожие с этими:

1 воркер:  Общее время выполнения 5034 мс
2 воркера: Общее время выполнения 2421 мс
4 воркера: Общее время выполнения 1018 мс

Давайте глубже взглянем на код.

* Воркеры читают данные из вентилятора и отправляют их в сток. Это означает что вы можете произвольно добавлять воркеров. Если бы конечные точки задавались на воркерах вам прошлось бы (1). Использовать больше конечных точек и (2) Постоянно перезапускать вентилятор и сток, как только вы добавили воркера. По этому мы решили что вентилятор и раковина будут статичными, а воркеры динамичными.

* Мы должны синхронизировать начало запуска со всеми подключившимися воркерами. Это жовольно распространенная проблема встречающаяся в Зере и не существует волшебной таблетки. Метод zmq_connect занимает определенное время. По этому первый из воркеров который подключился, получит всю пачку задач пока все остальные подключаются. Если вы не синхронизируете запуск всей пачки сообщений, система не будет работать параллельно. Можете попробовать и убрать ожидание в вентиляторе.

* PUSH сокет вентилятора распределяет задачи между воркерами равномерно(при условии что они все подключились к моменту раздачи). Это называется "балансировкой нагрузки"(load
balancing). Это мы опять же рассмотрим позже.

* PULL сокет слива собирает результаты от воркеров равномерно это называется "справедливой очередью" (fairqueuing) (см. рисунок 6).

Конвеерному паттерну(pipeline pattern) так же свойственен синдром "тормоза"(slow joiner), что приводит к обвинению в том что PUSH сокет не правильно использует балансировщик нагрузки. Если вы используете пару PUSH/PULL и один из вашир воркеров получает больше задач чем остальные, это связано с тем что PULL сокет вашего воркера быстрее подключается чем остальные, и хапает слишком много сообщений, пока другие не подключились. Если вы ищите способы правильной балансировки то вам необходимо прочитать на "Продвинутые паттерны запрос-ответ"(Advanced
Request-Reply Pattern) 

### ПРОГРАММИРОВАНИЕ С ЗЕРОЙ. (Programming with ØMQ)

Рассмотрев несколько примеров вы скорее всего уже рветесь внедрять Зеру в свои проекты. Не спешите, сделайте глубокий вдох и задумайтесь над теми советами которые сэкономят вам время и нервы.

* Шаг за шагом полностью изучите Зеру. Это не большая api но она дает уйму возможностей.
* Пишите чистый код. Код с душком несет в себе кучу проблем и усложняет жизнь как вам так и тем кто будет работать после вас. Вы можете превыкнуть к несуразным названиям переменных, но люди кто заглянет в ваш код вздернутся от такого. Используйте именование отражающее реальность. Не надо думать что вы слишком круты чтобы объяснять посредством переменных что происходит в коде. Пишите хороший код и всем будет легче.
* Пишите тесты. Это поможет вам разобраться с магией Зеры и понять что ошибка кроется именно в этих вот пяти строках. Особенно это полезно на первых порах освоения Зеры.
* Если у вас что то работает не так как вы ожидаете, разбейте ваш код на состовные части и протестируйте каржый по отдельности.
* Используйте абстракции(Классы, методы, без разницы). Не забывайте что при копипасте кода вы копируете и ошибки тоже.

### ПОЛУЧАЕМ КОНТЕКСТ ПРАВИЛЬНО (Getting the Context Right)

Первым шагом при работе с Зерой всегда будет создание контекста, и использование его при создании сокетов. В Си это вызов метода zmq_ctx_new(). Можно использовать только один экземпляр контекста на процесс. Говоря техническия языком, контекст это контейнер для сокетов текущего процесса, и выполняет транспортную функцию для сокетов inproc, которые являются самыми быстрыми для передачи данных между процессами. Если процесс имеет два контекста, то они являются разными экземплярами Зеры. Импользуйте несколько экземпляров если вам действительно это необходимо. Однако если нужды в этом не то запомните:

Создавайте только один экземпляр вначале выполнения вашего кода функцией zmq_ctx_new() и не забывайте его удалять по окончанию функцией zmq_ctx_destroy(). Если вы форкаете свои процессы, то каждый из процессов потомков должен иметь своий отдельный контекст. Если вы вызывает zmq_ctx_new() до форка, то можно не беспокоиться, каждый из потомков получит свой собственный контекст. В основном все интересные процессы протекают в процессах потомках, а родительский процесс просто ими управляет.

### ДЕЛАЕМ ЧИСТЫЙ ВЫХОД.

У классных программистов есть девиз - хорошие киллеры всегда подчищают за собой. Если вы использует языки подобные Python, то все почиститься автоматически. Но когда вы используете СИ, необходимо внимательно относиться к уничтожению объектов когда они уже не нужны, иначе вы получите утечку памяти, нестабильное приложение и минус в карму.

Утечка памяти одно дело, другое дело в том что Зера очень чувствительна к тому как вы завершаете свою программу. Если вы оставите открытыми сокеты, то функция zmq_ctx_destroy() будет висеть вечно. Даже если вы позакрываете сокеты, но имеются ожидающие подключения или отправки, то zmq_ctx_destroy() будет ждать вечно, если вы не установить сокетам LINGER в ноль перед их закрытием.

Объекты за которыми нам нужно следить это сообщения, сокеты и контексты. К счастью это довольно легко делается, особенно в простых программах.

* Используйте zmq_send() и  zmq_recv() когда есть возможность, это избавит от непосредственной работы с объектами zmq_msg_t.
* Если вы пользуететсь  zmq_msg_recv(), то как только вы получили сообщение вызывайте zmq_msg_close().
* Если у вас в обороте целая пачка сокетов, которые постоянно приходистся открывать и закрывать, то это звоночек, что вам необходимо пересмотреть архитектуру своего приложения. В большинстве случает сокеты не закрываются до момента закрытия приложения.
* При завершении программы узакройте сокеты и вызовите zmq_ctx_destroy(). В таком случае контекст закроется.

Это все имеет значение если вы программируете на языке подобному СИ. На языках с автосборщикому мусора объекты подчистятся автоматически как только вы закроете программу. если вы используете исключения и операторные скобки, не забывайте подчищать за собой к примеру в блоке "final".

А вот если ваше приложение многопоточное то тут все становится куда сложнее. В следующей главе мы подробно поговорим про мультипоточность, но поскольку многие из вас пытаются бегать до того как научились ходить, то снизу мы на скорую руку накидаем коротенькое руководство о том как завершать многопоточные приложения.

Ну во-первых не используйте один и тот же сокет из разных потоков. Пожалуйста не спорьте об этом, а просто не делайте так и все. После этого нужно отулючить все сокеты имеющие запросы. Верным действием будет установить ожидание(LINGER) равным 1 секунде, после чего закрыть сокет.

Ну и наконец уничтожте контекст. Это приведет к тому что все отправки, получения или накопители дочерних процессов вывалятся с исключениями. Отловите их, установите задержку, и позакрывайте сокеты этих потоков, после чего можно завершить потоки. Не уничтожайте контексты дважды. И не забывайте что zmq_ctx_destroy вызыванная в родительком потоке будет ждать вечно пока не закроются все подключенные потоки.

Вуаля! Это бесчеловечно, заставлять каждого программиста изобретать свой велосипед по завершению программ, но используя языки программирования с авточисткой, такие танцы с бубном становятся не нужны.

### ЗАЧЕМ НАМ ВООБЩЕ НУЖНА ЗЕРА (Why We Needed ØMQ)

Теперь когда мы видели зеру в действии, давайте разберемся зачем она нужна.

На текущий момент множество приложений завязаны на сетевой взаимодействие, будь то внутренняя сеть или интернет. Много разработчиков бьются над проблемой обмена сообщениями. Кто-то использует готовые продукты очередей, но чаще всего пишутся свои велосипеды поверх протоколов TCP и UDP. Это довольно простые протоколы, но пересылка нескольких байт из точки А а точку Б может существенно отличаться и теряется надежность и гибкость.

Давайте рассмотрим типичную проблему с которой мы сталкиваемся при работе через чистый TCP. Любой модуль реализующий работу с сообщениями должен реализовывать большинсво из нижеперечисленного.


1. Как бы обрабатываем ввод-вывод? Мы обрабатываем и блокируем все это в блоке кода приложения или передаем это в отдельный слой на обработку? Это вопрос архитектуры. Блокирование ввода/вывода приводит к жесткой не масштабируемой архитектуре. Однако решение с отдельным слоем обработки очень тяжело реализовать  кореектно.
2. Сможем ли мы обрабатывать динамические сообщения и тп,то что не выходит за рамки шаблонных. Можем ли мы разделить клиенты и серверы, и ожидать что серверы никогда не исчезнут? А что если нам понадобится соединить сервер с сервером? Можем ли мы переподключаться через каждые несколько секунд?
3. Каким образом нам преобразовывать сообщение для передачи через сеть? Как нам поделить передаваемые данные таким образом, чтобы было легко читать и записывать не опасаясь за переполнение буфера, чтобы это было эффективно для маленьких данных, но адекватным для больших видюшек танцующих котиков в шляпах?
4. Как нам обрабатывать сообщения которые требуют немедленной отправки? В частности когда мы ждем, что сдохший компонент снова оживет? Должны ли мы отменить сообщение, положить его в базу данных или же в очередь на оперативной памяти?
5. Где нам хранить очередь сообщений? Что делать если один из компонентов читающих из очереди очень медленный и забивает своим чтением всю нашу очередь? Как мы будем от этого защищаться?
6. Что нам делать с потерянными сообщениями? Будем ли мы ждать обновления данных, запрашивать переотправки данных или же мы реализуем отдельный слой который будет отвечать за гарантированную доставку сообщения? А что если этот слой и развалится?
7. Что будет если нам понадобится использовать разные транспортные протоколы? Скажем широковещательную а не одноадресный TCP? Или к примеру IPv6? Нужно ли переписывать приложение или достаточно будет изменить абстрактный слой?
8. Как нам маршрутизировать сообщения? Можем ли мы отправить одно сообщение множеству подключений? Можем ли мы ответить первоначальному отправителю сообщения?
9. Как нам обмениваться сообщениями между приложеними реализованными на разных языках программирования? Можем ли мы переписать протокол отправки или просто пересобрать библиотеку? Если первое, то как при этом гарантировать стабильность стека сообщений? Если второе, то как гарантировать совместимость?
10. Как представлять сообщение которое может быть прочитано в разных архитектурах? Можем ли мы использовать строгую типизацию?
11. Как нам обрабатывать сбои в сети? Будем ли мы ждать или повторять действие, тихонечко игнорировать или отменять операцию вообще?

Возьмем типовай оупенсорсный проект такой как Hadoop Zookeeper(http://hadoop.apache.org/zookeeper/) и почитаем код на СИ в файле src/c/src/zookeeper.c(http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c). Когда я читал этот код в Январе 2013, было примерно 4200 строк загадочного незадокументированного кода, который реализовывал общение клиента с сервером. Я увидел плюс в том что он использует pool вместо select'a. Однако он должен использовать общий слой для работы и строго документированный протокол обмена сообщеними. Совершенно недопустимо кажды раз изобретать собственный велосипед снова и снова.

Но как сделать общий слой обмена сообщениями? Почему когда разработчикам требуется обмен сообщенями они реализовывают это поверх чистого TCP и решают все перечисленные проблемы снова и снова?

Оказывается реализация многоразовых систем обмена сообщениями не так то просто реализовать, поэтому многие FOSS(открытое свободное по) проекты пытавшиеся это сделать, проваливались, а коммерческие поекты были дико дорогими,сложными, хрупкими и не гибкими. В 2006 году iMatix разработала AMQP, и раздал его разработчикам FOSS, возможно первый в своем роде рецепт для создания универсального обмена сообщениями. AMQP работает лучше многих других подобных конструкций, но остается достаточно сложным, дорогим и хрупким(http://www.imatix.com/articles:whats-wrong-with-amqp/). Требуются недели на то чтобы разобраться и месяцы чтобы построить стабильную архитектуру, которая не падает при увеличении функционала.

Рисунок 7 - Как мы представляем обмен в начале (Messaging as it Starts)

Множество проекто по обмену сообщениями, такие как amqp, которые пытаются решить весь длинный список проблем, чтобы пойти по пути переиспользуемого уровня, вводят новый принцип называемы брокером("broker"), который занимается адресацией, маршрутизацией и очередью. Это позволяет протоколу Клиент/Сервер или набору API над не задукументированный протоколом общаться через этого брокера. Брокер, отличная штука, снижающая сложность работы с сетью. Но добавление концепции брокера в такие проекты как Zookeeper сделает его более кривым нежели добавит улучшений. Это означет, что появится еще одна точка отказа. Брокер бастро становится узким горлышком проекта и соответственно добавляетс риски. Если приложение позволяет, мы можем предположить что добавив второй, третий, четвертый брокер мы построим таким образом отказоустойчивую схему. Но это не так. На практике это приводит к большему количеству подвижных, жестко связных частей приложения, которые могут сломаться.

Концепция с брокером в центре системы требует задействовать всю нашу команду. Мы буквально вынуждены денно и ночно следить за брокерами и бить из палками чтобы они работали. Вам нужны под них контейнеры, резервные копии этих контейнеров, а так же специальный человек который за это все добро отвечает. Так стоит поступать только для действительно больших приложений, со множеством распределенных частей, построенных множеством людей за многие годы работы.

Рисунок 8 - Во что превращается обмен по итогу (Messaging as it Becomes)

Разработчики не больших приложений попадают вловушку. Если они избегают сетевого обмена и строят монолиты, то приложения оказываются хрупкими, не расширяемыми, а так же тяжелыми для сопровождения. Либо же они идут по пути использования обмена сообщениями, делая приложение более масштабируемым и завязываются на дорогостоящую, тяжелоподдерживаемую технологию. Ни один из вариантов не решает проблему, возможно по этому технология обмена сообщениями застряла в прошлом веке и вызывает кучу эмоций: негативные у пользователей и позитивные у тех кто продает этим пользователям техническую поддержку.

Что же нам действительно нужно, так это нечто выполняющее работу по обмену сообщениями между разными приложениями, со стоимостью стремящейся к нулю. Это должна быть библиотека, на которую достаточно ссылаться в коде, без каких лобо дополнительных зависимостей. Без добавления дополнителных подвижных кусочков кода, создающих дополнительные риски отказа приложения. Она должна быть кроссплатформенной и мультиязычной.

И это ZeroMQ: Эффективная, встраеваемая библиотека которая решает большинство проблем связанных с обменом по сети без особых затрат.

А именно:

- Асинхронно обрабатывает потоки ввода/вывода в фоновых потоках. Общение с потоками приложения происходит через не блокируемые структуры, что обеспечивает конкурентные потоки без необходимости блокировок, семафоров и других всевозможных статусов.

- Компоненты могут подключаться и отключаться динамически и зера автоматически переподключится. Это означает, что вы можете запустить компонент когда вам вздумается. Вы можете построить сервисно-ориентированную архитектуру, в которой компоненты могут присоединяться когда им вздумается.

- Сообщения поместятся в очередь когда это необходимо. Зера поступает интеллектуально, отправляя сообщения так быстро, как это возможно, до того как поместить их в очередь.

- Зера имеет механизм которые помогает при переполнении очереди, так называемую вотерлинию. Она блокирует отправителей иже же выбрасывает сообщения в зависимости от выбранного паттерна обмена сообщениями.

- Позволяет обмениваться между приложениями через абстракцию, не зависимо от того какой протокол используется: TCP, широковещательный ("multicast"), внутри процессый ("in-process" внутри одного процесса), межпроцессный ("inter-process" - между разными процессами). При этом для того чтобы пользоваться разными протоколами не придется вносить изменения в ваш код.

- Безопасно обрабатывает чтение долких/блокируемых потоков, используя различные стратекии взависимости от выбранного паттерна обмена.

- Позволяет гибко настраивать маршрутизацию ваших сообщений используя разные типы подключений, таких как запрос-ответ или публицист-подписчик. Такие шаблоны отражают топологию вашего сетевого обмена. 
- Позволяет создавать прокси серверы для очередей, перенаправления, или упаковать пачку сообщений в одиночный вызов. Прокси могут помочь снизить сложность межсетевых соединений.
- Доставляет сообщения в том виде, в котором вы их отправили, используя простейший принцип передачи пакетов по сети. Если вы отправили сообщение в 10 кб, то по сети будет передано так же 10 кб.
- Не накладывает ограничений на формат и размер пересылаемых данных. Можно передать от нуля до гигабайт данных. Нет ограничений на верхнеуровневые структуры, вы можете использовать все что угодно например msgpack, Google's protocol buffers и тд.
- Интеллектуально обрабатывает сетевые ошибки, пытаясь переотправить сообщения если это имеет смысл.
- Меньше загрязняет окружающую среду. Зера меньше нугружает ваши системники, а следовательно потребляет меньше энергии и меньше загрязняет окружающую среду.

На самом деле Зера может куда больше перечисленного. Она оказывает сильное влияние на то, как вы строете свои приложения по сетевому обмену. Если кратко, это API поверх сокетов, а вам всего лишь нужно оперировать  zmq_recv() и zmq_send(). Одноко рано или поздно, обмен сообщениями становится центральным звено программы и разбивается на набор подзадачь. И это естественный процесс тут нечего бояться. С Зерой это легко масштабируется: каждая из задачь сопоставляется узлу, узел общается с другим узлом через произвольный транспорт. При этом нет необходимости задумываться как их делить, зера с этим справится сама. Два узла на процесс (значит узел это поток), если два узла на сервер (значит узел это процесс), или два уза на сеть (значит узел это сервер), при это ничего в коде менять не надо.

## Расширяемость сокетов (Socket Scalability)

Давайте посмотрим на расширяемость Зеры в действии. Ниже приведен shell скрип, параллельно запускающий сервер и пачку клиентов.

```
wuserver &
wuclient 12345 &
wuclient 23456 &
wuclient 34567 &
wuclient 45678 &
wuclient 56789 &
```
Как только мы запустились, можно посмотреть активность процессов командой top. Вополнив команду мы увидим нечто похожее (На четырех ядерной системе)

```
PID  USER  PR  NI  VIRT  RES  SHR S %CPU %MEM   TIME+  COMMAND
7136  ph   20   0 1040m 959m 1156 R  157 12.0 16:25.47 wuserver
7966  ph   20   0 98608 1804 1372 S   33  0.0  0:03.94 wuclient
7963  ph   20   0 33116 1748 1372 S   14  0.0  0:00.76 wuclient
7965  ph   20   0 33116 1784 1372 S    6  0.0  0:00.47 wuclient
7964  ph   20   0 33116 1788 1372 S    5  0.0  0:00.25 wuclient
7967  ph   20   0 33072 1740 1372 S    5  0.0  0:00.35 wuclient
```

Давайте разберемся что же тут произошло. Погодный сервер имеет всего один сокет, и отправляет данные клиентам параллельно. У нас могут быть тысячи параллельно подключенных клиентов. Сервер не видит их и не общается с ними напрямую. По сути сокет зеры это маленький сервер, тихонечко принимающий запросы и отправляющий ответы так быстро, насколько это позволяет сетевое соединение. И этот многопоточный сервер отжирает больше вашего процессора.

## Обновление с ZeroMQ v2.2 до ZeroMQ v3.2 (Upgrading from ZeroMQ v2.2 to ZeroMQ v3.2)

### Совместимые изменения (Compatible Changes)

Эти изменения не влияют на код непосредственно
- Фильтрация издатель/подписчик (pub-sub) перенесена на стророну издателя. Это позволяет существенно повысить производительность в большинстве случаев. Вы можете безопасно использовать версии v3.2 и v2.1/v2.2 одновременно, не беспокоясь о совместимости. ZeroMQ v3.2 получила множество новых API (zmq_disconnect(), zmq_unbind(), zmq_monitor(), zmq_ctx_set(), и тд.).

### Несовместимые изменения (Incompatible Changes)

- Изменены методы отправки/получения(send/recv): zmq_send() и zmq_recv() теперь отличаются, старый интерфейс и поведение теперь реализованы в методах zmq_msg_send() и zmq_msg_recv(). Симптомы: Ошибка компиляции. Решение: исправьте методы в коде.
- Эти две функции возвращали положительное число при успешной обработке и -1 при ошибке. В v2.x они всегда возвращают 0 при успешной обработке. Симптомы: Получение ошибки при успешной работе. Решение: Строго проверяйте на -1, а не на не нулевое значение.
- zmq_poll() сейчас ожидает миллисекунда, а не микросекунды как было раньше. Симптомы: Приложение перестало отвечать (По факту отвечает, но в 1000 раз медленнее.). Решение: Используйте макрос ZMQ_POLL_MSEC до вызова zmq_poll().
- ZMQ_NOBLOCK сейчас называется ZMQ_DONTWAIT. Симптомы: Ошибка помпиляции на строке ZMQ_NOBLOCK.
- Параметр сокета ZMQ_HWM разделен на два ZMQ_SNDHWM и ZMQ_RCVHWM. Симптомы: Ошибка компиляции на строке макроса ZMQ_HWM.
- Большинство, но не все, параметров zmq_getsockopt() сейчас имеют тип integer. Симптомы: Ошибка во время выполнения, при вызове zmq_setsockopt или zmq_getsockopt.
- Параметр ZMQ_SWAP был удален. Симптомы: Ошибка во время компиляции. Решение: Переделайте свой код.

###  Рекоммендации по макросам (Suggested Shim Macros)

Для тех кто хочет работать на двух версиях сразу, мы советует эмулировать третью версию используя макросы, если это конечно позволяет язык. Вот определения макросов C, которые помогают вашему C/C++ коду работать в обеих версиях (взято из [CZMQ](http://czmq.zeromq.org/)):

```
#ifndef ZMQ_DONTWAIT
#   define ZMQ_DONTWAIT     ZMQ_NOBLOCK
#endif
#if ZMQ_VERSION_MAJOR == 2
#   define zmq_msg_send(msg,sock,opt) zmq_send (sock, msg, opt)
#   define zmq_msg_recv(msg,sock,opt) zmq_recv (sock, msg, opt)
#   define zmq_ctx_destroy(context) zmq_term(context)
#   define ZMQ_POLL_MSEC    1000        //  zmq_poll is usec
#   define ZMQ_SNDHWM ZMQ_HWM
#   define ZMQ_RCVHWM ZMQ_HWM
#elif ZMQ_VERSION_MAJOR == 3
#   define ZMQ_POLL_MSEC    1           //  zmq_poll is msec
#endif
```

## Внимание: Разногласие парадигм! (Warning: Unstable Paradigms!)

Традиционная сетевая разработка строится на утверждении, что один сокете это одно соединение с одним клиентом. Существуют широковещательные протоколы, но это скорее экзотика. Когда мы утверждаем "одно соединение = один сокет", мы масштабируем наши приложения только определенным образом. Мы завязываемся на логику где один поток это один сокет с одним плиентом. Мы начинаем мыслить этим соглашением.

Во вселенной ZeroMq сокеты это проход к быстрому, маленькому, фоновому движку, который обеспечивает механизм обмена за вас. Вы не видите как они работают, открывают, закрывают соединение. Независимо от того используете ли вы блокировку при отправке/получении или же пулл(poll), вы делаете это через сокет, а не через соединение. Реализация соединений инкапсулирована от вас и это ключ к масштабированию Зеры.

Поскольку ваш код общается только с сокетом, за ним может скрываться сколько угодно подключений на различных протоколах, что для вас остается прозрачным. Шаблоны предоставляемые ZeroMQ куда легче масштабируются, нежели шаблоны которые вы бы создавали у себя в коде.

Таким образом устоявшееся соглашение что один сокет это одно соединение больше не действует. Когда вы читаете код примеров ваш мозг пытается сопоставить это с тем что вы уже знаете. Вы читаете socket и думаете "а, это означает подключение к другому узлу". Вы ошибаетесь. Вы читаете thread и думаете "а, это означает подключение к другому узлу", и ваш мозг снова вас обманывает.

Если вы только читаете это руководство или может используете зеру первые день-два или может даже три-четыре, вы чувствуете себя не в своей такрелке. Вы пытаетесь построить приложение на тот манер к которому превыкли и у вас ничего не работает. Вас смущает, что зера делает за вас много вещей и все становится слишком просто. Но однажды вы осознаете преимущества и произойдет сдвиг устоявшейся парадигмы в вашем мозгу. И вот тогда то все встанет на своим места.








































