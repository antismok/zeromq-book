# Глава 2. Сокеты и паттерны (Sockets and Patterns)

В [главе 1 - Основы](http://) мы обкатали Зеру на примерах с основными паттернами: запрос-ответ(request-reply), издатель-подписчик(pub-sub), и пайпы(pipeline). В этой главе мы запачкаем руки и начнем изучать использвание этих паттернов в реальной жизни.

Мы затронем следующие вопросы:

- Как создавать и работать с сокетами Зеры
- Как отправлять и получать сообщения через сокеты
- Как констроуривать ваши приложения вокруг асинхронной модели Зеры
- Как работать с набором сокетов в одном потоке.
- Как обрабатывать критичные и не критичные ошибки.
- Как обрабатывать такие сигналы как Ctrl-C
- Как правильно завершать работу с Зерой
- Как проверить приложение с Зерой на утечку памяти
- Как отправлять и получать составные сообщения
- Как перенаправлять сообщения в сети
- Как созадать простейшего брокера очередей
- Как создавать многопоточные приложения с Зерой
- Как обмениваться сигналами между потоками при помощи Зеры
- Как управлять наборами коненых узлов при помощи Зеры (Может подобрать другой перевод)
- Как создавать и управлять пакетами сообщений для паттерна издатель-подписчик
- Использование HWM ("вотерлинии") для защиты от переполнения памяти

## Интерфейсы сокетов (The Socket API)

Если быть честными, то Зера заманивает вас знакомым api, призванным скрыть движок обмена сообщениями под капотом. Извиняться за такого рода заманивания мы не собираемся, ведь это все для вашего же блага. Мы потратили не мало усилий, чтобы запихнуть все за такой знакомый api. Со временем это принесет свои плоды и ваш взгляд на создание распределенных программ изменится.

Вообще сокеты изначально являются стандартным api для сетевого программирования и созданы для того чтобы ваши глаза не вывалились от всего происходящего под капотом. Одно из преимуществ Зеры это то, что она позволяет огрничиться сокетами и сообщениями, всесто венегрета из понятий. Отдельное спасобо Martin Sustrik за добавление понятия "Message Oriented Middleware", которое позволяет избавиться от разномастных сокетов.

Разобраться в сокетах Зеры очень простосто. Они как и сокеты BSD, имеют четыре действия.

- Создание и удаление сокетов (см. [zmq_socket()](http://api.zeromq.org/3-2:zmq_socket), [zmq_close()](http://api.zeromq.org/3-2:zmq_close));
- Настройка сокетов, путем изменения определенных параметров, а так же проверка этих параметров при необходимости.(см.[zmq_setsockopt()](http://api.zeromq.org/3-2:zmq_setsockopt), [zmq_getsockopt()](http://api.zeromq.org/3-2:zmq_getsockopt)).
- Подключение сокетов к сетевой топологии путем создания подключения на прослушивание или отправку. (см. [zmq_bind()](http://api.zeromq.org/3-2:zmq_bind), [zmq_connect()](http://api.zeromq.org/3-2:zmq_connect)).
- Использование сокетов для обмена сообщениями (см. [zmq_msg_send()](http://api.zeromq.org/3-2:zmq_msg_send), [zmq_msg_recv()](http://api.zeromq.org/3-2:zmq_msg_recv)).

Обратите внимание что сокеты являются указателями типа void, а сообщения(до них мы еще доберемся) это структуры. Если брать Си, то в функции обмена сообщениями, такие как [zmq_msg_send()](http://api.zeromq.org/3-2:zmq_msg_send) и [zmq_msg_recv()]( zmq_msg_recv()), вы передаете сокеты в том виде в котором они есть, а вот вместо сообщения передается его адрес. Чтобы проще это понять, скажем что в ZeroMQ все ваши сокеты принадлежат нам, а сообщения вам.

Создание, уничтожение и настройка сокетов ведут себя так, как вы от них и ожидаете. Тоесть как и любой другой объект. Но не забывайте, что Зера это гибкий, асинхронный инструмент. И то какие типы сокетов мы создаем, влияет на то какие действия мы можем с их помощью совершать.

## Добавление сокетов в топологию (Plugging Sockets into the Topology)

Для установки связи между двумя узлами используйте [zmq_bind()](http://api.zeromq.org/3-2:zmq_bind) с одной стороны и [zmq_connect()](http://api.zeromq.org/3-2:zmq_connect) с другой. По правилам хорошего то сторона использующая [zmq_bind()](http://api.zeromq.org/3-2:zmq_bind) является сервером с открытым адресом, а [zmq_connect()](http://api.zeromq.org/3-2:zmq_connect) является клиентом с неизвестным или произвольным адресом. Таким образом мы говорим, что "привязываем сокет к конечной точке" и "подключаем сокет к конечной точке", конечной точкой является хорошо известный сетевой адрес.

Сокеты ZMQ несколько отличаются от классический TCP сокетов. Ниже перечислены некоторые самые примечательные из них.

- Они работают поверх произвольного транспорта (inproc, ipc, tcp, pgm, или epgm).Смотрите функции [zmq_inproc()](http://api.zeromq.org/3-2:zmq_inproc), [zmq_ipc()](http://api.zeromq.org/3-2:zmq_ipc), [zmq_tcp()](http://api.zeromq.org/3-2:zmq_tcp), [zmq_pgm()](http://api.zeromq.org/3-2:zmq_pgm), и [zmq_epgm()](http://api.zeromq.org/3-2:zmq_epgm).
- Один сокет может иметь множество входящих и исходящих подключений
- Отсутствие необходимости в методе zmq_accept(). Как только сокет подключился к конечно точке, он автоматически подтверждает соединение.
- Подключение происходит в фоновом режиме и ZMQ автоматически пререподключается при обрыве связи.
- Ваш код не работает с соединение напрямую. Все инкапсулировано в сокет.

Множество архитектус следуют клиент-серверной архитектуре. Тоесть серверная часть является статичной, а клиентская динамична, тоесть постоянно подключаются и отключаются. Иногда возникают проблемы с адресацией: серверы будут видны клиентам, но не обязательно наоборот. В основном понятно на какой стороне должен быть сервер, а на какой клиент. Так же это зависит от типа сокетовв некоторых специфичных архитектурах. Типы этих сокетом будут рассмотрены позже.

Теперь представьте, что мы запустили клиента до запуска сервера. В традиционном подходе мы получим фатольную ошибку. Но механизм zqm позволяет нам запускать кусочки нашей архитектуры независимо. Соединение существует с того момента как клиент выполняет [zmq_connect()](http://api.zeromq.org/3-2:zmq_connect) и клиент может начать записывать сообщения в сокет. В какой то момент (мы надеемся до того как очередь перепелнится и сообщения начьнут отбрасываться) сервер оживает, выполняет [zmq_bind()](http://api.zeromq.org/3-2:zmq_bind) и zqm начинает доставлять сообщения.

Серверный узел может подвешиваться на множество конечных точек (комбинацыю разных адремов и протоколов) при этом используя один сокет. Это продоставляет возможность соединения поверх различных протоколов.

```c
zmq_bind (socket, "tcp://*:5555");
zmq_bind (socket, "tcp://*:9999");
zmq_bind (socket, "inproc://somename");
```

С большинством транспортов вы не можете связываться с одной и той же конечной точкой дважды, в отличие, например, от UDP. Однако транспорт ipc позволяет одному процессу связываться с конечной точкой, уже используемой первым процессом. Он предназначен для восстановления процесса после сбоя.

Хотя zmq старается быть нейтральным по отношению к тому какая сторона прослушивает соединения, а какая подключается, различия все же существуют. Мы взглянем на это немного позже. В результате вы должны придерживаться того подхода, что серверы это более менее статическая часть вашей топологии и подвешиваются на редко меняющиеся узлы вашей топологии, а клиенты динамичны, приходят и уходят подключаясь к этим узлам. Потом вы разработаете приложение на основе этоги и вероятность того что это сработает будет выше.

Сокеты имеют типы. Тип сокета определяет его семантику, политики его маршрутизации, организацию очередей и тд. Вы можете подключить сокеты одного типа друг к другу. Например сокет издатель и сокет подписчик. Советы работают вместе в шаблонах обмена сообщениями. Детально мы посмотрим на это позже.

Именно способность соединять сокеты различными способами дает ZeroMQ базовые возможности в качестве системы очереди сообщений. Поверх этого есть слои, такие как прокси, к которым мы вернемся позже. Но по сути, с ZeroMQ вы определяете свою сетевую архитектуру, соединяя части, как в конструкторе Лего.
