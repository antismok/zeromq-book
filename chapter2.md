# Глава 2. Сокеты и паттерны (Sockets and Patterns)

В [главе 1 - Основы](http://) мы обкатали Зеру на примерах с основными паттернами: запрос-ответ(request-reply), издатель-подписчик(pub-sub), и пайпы(pipeline). В этой главе мы запачкаем руки и начнем изучать использвание этих паттернов в реальной жизни.

Мы затронем следующие вопросы:

- Как создавать и работать с сокетами Зеры
- Как отправлять и получать сообщения через сокеты
- Как констроуривать ваши приложения вокруг асинхронной модели Зеры
- Как работать с набором сокетов в одном потоке.
- Как обрабатывать критичные и не критичные ошибки.
- Как обрабатывать такие сигналы как Ctrl-C
- Как правильно завершать работу с Зерой
- Как проверить приложение с Зерой на утечку памяти
- Как отправлять и получать составные сообщения
- Как перенаправлять сообщения в сети
- Как созадать простейшего брокера очередей
- Как создавать многопоточные приложения с Зерой
- Как обмениваться сигналами между потоками при помощи Зеры
- Как управлять наборами коненых узлов при помощи Зеры (Может подобрать другой перевод)
- Как создавать и управлять пакетами сообщений для паттерна издатель-подписчик
- Использование HWM ("вотерлинии") для защиты от переполнения памяти

## Интерфейсы сокетов (The Socket API)

Если быть честными, то Зера заманивает вас знакомым api, призванным скрыть движок обмена сообщениями под капотом. Извиняться за такого рода заманивания мы не собираемся, ведь это все для вашего же блага. Мы потратили не мало усилий, чтобы запихнуть все за такой знакомый api. Со временем это принесет свои плоды и ваш взгляд на создание распределенных программ изменится.

Вообще сокеты изначально являются стандартным api для сетевого программирования и созданы для того чтобы ваши глаза не вывалились от всего происходящего под капотом. Одно из преимуществ Зеры это то, что она позволяет огрничиться сокетами и сообщениями, всесто венегрета из понятий. Отдельное спасобо Martin Sustrik за добавление понятия "Message Oriented Middleware", которое позволяет избавиться от разномастных сокетов.

Разобраться в сокетах Зеры очень простосто. Они как и сокеты BSD, имеют четыре действия.

- Создание и удаление сокетов (см. [zmq_socket()](http://api.zeromq.org/3-2:zmq_socket), [zmq_close()](http://api.zeromq.org/3-2:zmq_close));
- Настройка сокетов, путем изменения определенных параметров, а так же проверка этих параметров при необходимости.(см.[zmq_setsockopt()](http://api.zeromq.org/3-2:zmq_setsockopt), [zmq_getsockopt()](http://api.zeromq.org/3-2:zmq_getsockopt)).
- Подключение сокетов к сетевой топологии путем создания подключения на прослушивание или отправку. (см. [zmq_bind()](http://api.zeromq.org/3-2:zmq_bind), [zmq_connect()](http://api.zeromq.org/3-2:zmq_connect)).
- Использование сокетов для обмена сообщениями (см. [zmq_msg_send()](http://api.zeromq.org/3-2:zmq_msg_send), [zmq_msg_recv()](http://api.zeromq.org/3-2:zmq_msg_recv)).

Обратите внимание что сокеты являются указателями типа void, а сообщения(до них мы еще доберемся) это структуры. Если брать Си, то в функции обмена сообщениями, такие как [zmq_msg_send()](http://api.zeromq.org/3-2:zmq_msg_send) и [zmq_msg_recv()]( zmq_msg_recv()), вы передаете сокеты в том виде в котором они есть, а вот вместо сообщения передается его адрес. Чтобы проще это понять, скажем что в ZeroMQ все ваши сокеты принадлежат нам, а сообщения вам.

Создание, уничтожение и настройка сокетов ведут себя так, как вы от них и ожидаете. Тоесть как и любой другой объект. Но не забывайте, что Зера это гибкий, асинхронный инструмент. И то какие типы сокетов мы создаем, влияет на то какие действия мы можем с их помощью совершать.

